#!/usr/bin/env python3
# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Generate ruff-legacy.toml and managed blocks from legacy-files.txt.

Generates ruff-legacy.toml and managed blocks in pyproject.toml /
.pre-commit-config.yaml from legacy-files.txt (single source of truth).

Usage:
    python scripts/generate_legacy_lint_config.py              # --generate (default)
    python scripts/generate_legacy_lint_config.py --generate   # write files in-place
    python scripts/generate_legacy_lint_config.py --check      # verify freshness (CI)
    python scripts/generate_legacy_lint_config.py --prune      # remove stale paths from legacy-files.txt
"""

from __future__ import annotations

import argparse
import difflib
import os
import sys
from pathlib import Path

try:
    from jinja2 import Environment, FileSystemLoader
except ImportError:
    print(
        "ERROR: jinja2 is required. Install with: pip install jinja2",
        file=sys.stderr,
    )
    sys.exit(1)

# ---------------------------------------------------------------------------
# Paths (relative to repo root)
# ---------------------------------------------------------------------------
REPO_ROOT = Path(__file__).resolve().parent.parent
LEGACY_FILES_TXT = REPO_ROOT / "legacy-files.txt"
TEMPLATES_DIR = REPO_ROOT / "scripts" / "templates"

RUFF_LEGACY_TOML = REPO_ROOT / "ruff-legacy.toml"
PYPROJECT_TOML = REPO_ROOT / "pyproject.toml"
PRECOMMIT_YAML = REPO_ROOT / ".pre-commit-config.yaml"

# Marker strings used to delimit auto-generated blocks
BEGIN_MARKER = "# <<<< BEGIN AUTO-GENERATED by scripts/generate_legacy_lint_config.py >>>>"
END_MARKER = "# <<<< END AUTO-GENERATED >>>>"


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def read_legacy_files() -> list[str]:
    """Read legacy-files.txt and return sorted, non-empty, non-comment lines."""
    if not LEGACY_FILES_TXT.exists():
        print(f"ERROR: {LEGACY_FILES_TXT} not found", file=sys.stderr)
        sys.exit(1)
    paths = []
    for line in LEGACY_FILES_TXT.read_text().splitlines():
        line = line.strip()
        if line and not line.startswith("#"):
            paths.append(line)
    return sorted(set(paths))


def validate_paths(paths: list[str]) -> list[str]:
    """Warn about paths that don't exist on disk. Return list of stale paths."""
    stale = []
    for p in paths:
        if not (REPO_ROOT / p).exists():
            stale.append(p)
    if stale:
        print(f"WARNING: {len(stale)} stale entries in legacy-files.txt:", file=sys.stderr)
        for s in stale:
            print(f"  {s}", file=sys.stderr)
    return stale


def render_template(template_name: str, paths: list[str]) -> str:
    """Render a Jinja2 template with the given paths list."""
    env = Environment(
        loader=FileSystemLoader(str(TEMPLATES_DIR)),
        keep_trailing_newline=True,
    )
    template = env.get_template(template_name)
    return template.render(paths=paths)


def replace_managed_block(content: str, new_block: str) -> str:
    """Replace content between BEGIN/END markers with new_block.

    The new_block should include the BEGIN and END markers themselves.
    """
    begin_idx = content.find(BEGIN_MARKER)
    end_idx = content.find(END_MARKER, begin_idx + len(BEGIN_MARKER))

    if begin_idx == -1 or end_idx == -1:
        print(
            f"ERROR: Could not find managed block markers:\n"
            f"  BEGIN: {BEGIN_MARKER}\n"
            f"  END:   {END_MARKER}",
            file=sys.stderr,
        )
        sys.exit(1)

    # Include everything up to the end of the END marker line
    end_line_end = content.index("\n", end_idx) + 1

    return content[:begin_idx] + new_block + content[end_line_end:]


def show_diff(label: str, old: str, new: str) -> bool:
    """Print unified diff if different. Return True if they differ."""
    if old == new:
        return False
    diff = difflib.unified_diff(
        old.splitlines(keepends=True),
        new.splitlines(keepends=True),
        fromfile=f"a/{label}",
        tofile=f"b/{label}",
    )
    sys.stdout.writelines(diff)
    return True


# ---------------------------------------------------------------------------
# Generation
# ---------------------------------------------------------------------------


def generate_ruff_legacy_toml(paths: list[str]) -> str:
    """Generate the full ruff-legacy.toml content."""
    return render_template("ruff-legacy.toml.j2", paths)


def generate_pyproject_block(paths: list[str]) -> str:
    """Generate the managed block for pyproject.toml [tool.ruff.format] exclude."""
    return render_template("pyproject-format-exclude.j2", paths)


def generate_precommit_block(paths: list[str]) -> str:
    """Generate the managed block for .pre-commit-config.yaml file anchors."""
    return render_template("precommit-legacy-files.j2", paths)


# ---------------------------------------------------------------------------
# Main actions
# ---------------------------------------------------------------------------


def do_generate(paths: list[str]) -> None:
    """Write all generated files in-place."""
    # 1. ruff-legacy.toml (full file write)
    new_toml = generate_ruff_legacy_toml(paths)
    RUFF_LEGACY_TOML.write_text(new_toml)
    print(f"  Written: {RUFF_LEGACY_TOML.relative_to(REPO_ROOT)}")

    # 2. pyproject.toml (replace managed block)
    old_pyproject = PYPROJECT_TOML.read_text()
    new_block = generate_pyproject_block(paths)
    new_pyproject = replace_managed_block(old_pyproject, new_block)
    PYPROJECT_TOML.write_text(new_pyproject)
    print(f"  Updated: {PYPROJECT_TOML.relative_to(REPO_ROOT)}")

    # 3. .pre-commit-config.yaml (replace managed block)
    old_precommit = PRECOMMIT_YAML.read_text()
    new_block = generate_precommit_block(paths)
    new_precommit = replace_managed_block(old_precommit, new_block)
    PRECOMMIT_YAML.write_text(new_precommit)
    print(f"  Updated: {PRECOMMIT_YAML.relative_to(REPO_ROOT)}")


def do_check(paths: list[str]) -> None:
    """Check freshness â€” exit 1 with diff if any file is stale."""
    any_stale = False

    # 1. ruff-legacy.toml
    expected = generate_ruff_legacy_toml(paths)
    actual = RUFF_LEGACY_TOML.read_text() if RUFF_LEGACY_TOML.exists() else ""
    if show_diff("ruff-legacy.toml", actual, expected):
        any_stale = True

    # 2. pyproject.toml
    old_pyproject = PYPROJECT_TOML.read_text()
    new_block = generate_pyproject_block(paths)
    expected_pyproject = replace_managed_block(old_pyproject, new_block)
    if show_diff("pyproject.toml", old_pyproject, expected_pyproject):
        any_stale = True

    # 3. .pre-commit-config.yaml
    old_precommit = PRECOMMIT_YAML.read_text()
    new_block = generate_precommit_block(paths)
    expected_precommit = replace_managed_block(old_precommit, new_block)
    if show_diff(".pre-commit-config.yaml", old_precommit, expected_precommit):
        any_stale = True

    if any_stale:
        print(
            "\nERROR: Generated configs are out of date. Run:\n"
            "  python scripts/generate_legacy_lint_config.py\n",
            file=sys.stderr,
        )
        sys.exit(1)
    else:
        print("All generated configs are up to date.")


def do_prune() -> None:
    """Remove stale paths from legacy-files.txt."""
    paths = read_legacy_files()
    stale = validate_paths(paths)
    if not stale:
        print("No stale entries found.")
        return
    valid = [p for p in paths if p not in set(stale)]
    LEGACY_FILES_TXT.write_text("\n".join(valid) + "\n")
    print(f"Pruned {len(stale)} stale entries. {len(valid)} entries remain.")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate legacy lint configs from legacy-files.txt"
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--generate",
        action="store_true",
        default=True,
        help="Write generated files in-place (default)",
    )
    group.add_argument(
        "--check",
        action="store_true",
        help="Verify generated files are up to date (CI mode)",
    )
    group.add_argument(
        "--prune",
        action="store_true",
        help="Remove stale paths from legacy-files.txt",
    )
    args = parser.parse_args()

    os.chdir(REPO_ROOT)

    if args.prune:
        do_prune()
        return

    paths = read_legacy_files()
    stale = validate_paths(paths)

    if stale and not args.check:
        print(
            "HINT: Run with --prune to remove stale entries.",
            file=sys.stderr,
        )

    if args.check:
        do_check(paths)
    else:
        do_generate(paths)


if __name__ == "__main__":
    main()
