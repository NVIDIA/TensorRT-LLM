#!/usr/bin/env python3

import collections as _col
import itertools as _it
import pathlib as _pl
import subprocess as _sp
import sys as _sys
import typing as _tp

DEFAULT_OWNERS = [
    'jdemouth@nvidia.com',
    'juney@nvidia.com',
    'tali@nvidia.com',
    'schetlur@nvidia.com',
    'martinma@nvidia.com',
]

# Maps directory names to a list of owners.
# Multiple directories can be assigned to the same group of owners by using tuples.
PICS = {
    "baichuan/": ["zhhuang@nvidia.com", "zhhuang@nvidia.com"],
    "bert/": ["haohangh@nvidia.com", "sipingw@nvidia.com"],
    "bloom/": ["dastokes@nvidia.com", "jinshik@nvidia.com"],
    "chatglm/": ["wili@nvidia.com", "enweiz@nvidia.com"],
    "enc_dec/":
    ["haohangh@nvidia.com", "jiayuc@nvidia.com", "sipingw@nvidia.com"],
    "falcon/": ["jaedeokk@nvidia.com", "jinshik@nvidia.com"],
    "gemma/": ["bhsueh@nvidia.com", "dongfengy@nvidia.com"],
    "gpt/": ["enweiz@nvidia.com", "bhsueh@nvidia.com"],
    "gptj/": ["guomingz@nvidia.com", "junq@nvidia.com"],
    "gptneox/": ["jiangs@nvidia.com"],
    "internlm/": ["guomingz@nvidia.com"],
    "llama/": ["anchengc@nvidia.com", "guomingz@nvidia.com", "junq@nvidia.com"],
    "mamba/": ["fanrongl@nvidia.com", "junliu@nvidia.com"],
    "mixtral/": ["dastokes@nvidia.com", "enweiz@nvidia.com"],
    "mpt/": ["junq@nvidia.com"],
    "multimodal/": ["amukkara@nvidia.com", "haohangh@nvidia.com"],
    "opt/": ["junq@nvidia.com"],
    "phi/": ["perkzz@nvidia.com"],
    "qwen/": ["jershi@nvidia.com"],
    "qwenvl/": ["qgai@nvidia.com"],
    "skywork/": ["pengyunl@nvidia.com"],
    "whisper/": ["yuekaiz@nvidia.com"],
    "medusa/":
    ["dongxuy@nvidia.com", "nkorobov@nvidia.com", "rhasan@nvidia.com"],
    ("cpp/tensorrt_llm/batch_manager/", "cpp/include/tensorrt_llm/batch_manager/", "cpp/tests/batch_manager/"):
    [
        "pcastonguay@nvidia.com", "kevxie@nvidia.com", "schetlur@nvidia.com",
        "tjohnsen@nvidia.com"
    ],
    ("cpp/tensorrt_llm/runtime/", "cpp/include/tensorrt_llm/runtime/", "cpp/tests/runtime/"):
    [
        "martinma@nvidia.com", "rkobus@nvidia.com", "nkorobov@nvidia.com",
        "xiaoweis@nvidia.com"
    ],
    "windows/": ["tejaswinp@nvidia.com"]
}


def all_files() -> _tp.List[str]:
    return [
        file for file in _sp.check_output(['git', 'ls-files']).decode(
            'utf-8').splitlines() if not file.startswith('3rdparty')
    ]


def top_n(xs: _tp.Sequence[str], n: int) -> _tp.List[str]:
    return [name for (name, _) in _col.Counter(xs).most_common(n)]


def main_authors(file: str) -> _tp.List[str]:
    # noinspection PyBroadException
    try:
        authors_per_line = [
            line.split()[1].strip('<>') for line in _sp.check_output([
                'git', 'blame', '--line-porcelain', file
            ]).decode('utf-8').splitlines() if line.startswith("author-mail")
        ]
        return top_n(authors_per_line, 2)
    except Exception as ex:
        print(f"/{file}: {ex}", file=_sys.stderr)
        return []


def base_dir(file: str) -> str:
    return str(_pl.Path(file).parent)


def file_name(file: str) -> str:
    return str(_pl.Path(file).name)


def safe_name(file: str) -> str:
    return file.replace(' ', '\\ ')


def matches_pic(directory: str) -> bool:
    dir_with_slash = directory + "/"

    def is_match(d: str) -> bool:
        is_absolute = d.startswith("/")
        return d.endswith("/") and (
            (is_absolute and dir_with_slash.startswith(d[1:])) or
            (not is_absolute and d in dir_with_slash))

    return any(is_match(pic) for pic in PICS.keys() if not isinstance(pic, tuple)) or \
        any(any(is_match(pic) for pic in pics) for pics in PICS.keys() if isinstance(pics, tuple))


def print_assignment(path, names):
    print(f"{safe_name(path)} {' '.join(names)}")
    if path.endswith("/"):
        print(f"{safe_name(path[:-1])} {' '.join(names)}")


def main():
    files = all_files()
    files.sort(key=lambda x: (base_dir(x), file_name(x)))

    print(f"# GENERATED BY {__file__}")

    print("\n# DEFAULT OWNERS\n")

    print_assignment("*", DEFAULT_OWNERS)

    print("\n# ASSIGNED BY COMMIT STATISTICS\n")

    for directory, dir_files in _it.groupby(files, base_dir):
        if matches_pic(directory):
            continue

        authors = {file: main_authors(file) for file in dir_files}
        dir_main_authors = list(_it.chain.from_iterable(authors.values()))

        if directory != '.' and dir_main_authors:
            print(
                f"/{safe_name(directory)} {' '.join(top_n(dir_main_authors, 3))}"
            )

        for file, main_auth in authors.items():
            if not (file.endswith(".cubin.cpp")
                    or "decoderMaskedMultiheadAttention" in file) and main_auth:
                print(f"/{safe_name(file)} {' '.join(main_auth)}")

    print("\n# ASSIGNED PICS\n")

    for path, names in PICS.items():
        if isinstance(path, tuple):
            for p in path:
                print_assignment(p, names)
        else:
            print_assignment(path, names)


if __name__ == '__main__':
    main()
