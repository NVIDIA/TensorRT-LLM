import json
import re
from typing import List

from .openai_protocol import ToolCall, FunctionCall, ChatCompletionToolsParam

# Pattern to detect function calls in model output
FUNCTION_CALL_PATTERN = (
    r"```json\s*(\{.*?\})\s*```|<function>\s*(\{.*?\})\s*</function>|<tool_call>\s*(\{.*?\})\s*</tool_call>"
)


def detect_and_parse_function_calls(text: str, available_tools: List[ChatCompletionToolsParam]) -> List[ToolCall]:
    """Detect and parse function calls from text generated by the model."""
    tool_calls = []
    # Map tool names to their definitions
    tool_map = {tool.function.name: tool.function for tool in available_tools}
    # Find potential function calls in the text
    matches = re.finditer(FUNCTION_CALL_PATTERN, text, re.DOTALL)
    for match in matches:
        # Fix: Check all possible capture groups (1, 2, or 3)
        json_str = match.group(1) or match.group(2) or match.group(3)
        try:
            function_data = json.loads(json_str)

            # Extract function name and arguments
            if "name" in function_data and "arguments" in function_data:
                function_name = function_data["name"]
                arguments = function_data["arguments"]

                # If arguments is a dict, convert to JSON string
                if isinstance(arguments, dict):
                    arguments = json.dumps(arguments)

                # Validate function name exists in available tools
                if function_name in tool_map:
                    tool_calls.append(ToolCall(function=FunctionCall(name=function_name, arguments=arguments)))
        except json.JSONDecodeError:
            continue  # Skip invalid JSON
    return tool_calls


def validate_function_arguments(
    function_name: str, arguments: str, available_tools: List[ChatCompletionToolsParam]
) -> bool:
    """Validate function arguments against JSON schema."""
    # Find the function definition
    function_def = None
    for tool in available_tools:
        if tool.function.name == function_name:
            function_def = tool.function
            break

    if not function_def or not function_def.parameters:
        return False

    try:
        # Parse arguments string to JSON
        args_json = json.loads(arguments)

        # For now, just check if the required parameters are present
        required = function_def.parameters.get("required", [])
        for param in required:
            if param not in args_json:
                return False

        return True
    except json.JSONDecodeError:
        return False
