<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Functionals &mdash; tensorrt_llm  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Models" href="tensorrt_llm.models.html" />
    <link rel="prev" title="Layers" href="tensorrt_llm.layers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            tensorrt_llm
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">TensorRT-LLM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpt_runtime.html">C++ GPT Runtime</a></li>
<li class="toctree-l1"><a class="reference internal" href="../batch_manager.html">The Batch Manager in TensorRT-LLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpt_attention.html">Multi-head, Multi-query and Group-query Attention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../precision.html">Numerical Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Performance of TensorRT-LLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Build From Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2023-05-19-how-to-debug.html">How to debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2023-05-17-how-to-add-a-new-model.html">How to add a new model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graph-rewriting.html">Graph Rewriting Module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tensorrt_llm.layers.html">Layers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functionals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.AllReduceStrategy"><code class="docutils literal notranslate"><span class="pre">AllReduceStrategy</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.AllReduceStrategy.AUTO"><code class="docutils literal notranslate"><span class="pre">AllReduceStrategy.AUTO</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.AllReduceStrategy.ONESHOT"><code class="docutils literal notranslate"><span class="pre">AllReduceStrategy.ONESHOT</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.AllReduceStrategy.RING"><code class="docutils literal notranslate"><span class="pre">AllReduceStrategy.RING</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.AllReduceStrategy.TWOSHOT"><code class="docutils literal notranslate"><span class="pre">AllReduceStrategy.TWOSHOT</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.AttentionMaskType"><code class="docutils literal notranslate"><span class="pre">AttentionMaskType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.AttentionMaskType.bidirectional"><code class="docutils literal notranslate"><span class="pre">AttentionMaskType.bidirectional</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.AttentionMaskType.causal"><code class="docutils literal notranslate"><span class="pre">AttentionMaskType.causal</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.AttentionMaskType.padding"><code class="docutils literal notranslate"><span class="pre">AttentionMaskType.padding</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.DimRange"><code class="docutils literal notranslate"><span class="pre">DimRange</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.LayerNormPositionType"><code class="docutils literal notranslate"><span class="pre">LayerNormPositionType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.LayerNormPositionType.post_layernorm"><code class="docutils literal notranslate"><span class="pre">LayerNormPositionType.post_layernorm</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.LayerNormPositionType.pre_layernorm"><code class="docutils literal notranslate"><span class="pre">LayerNormPositionType.pre_layernorm</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.LayerNormType"><code class="docutils literal notranslate"><span class="pre">LayerNormType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.LayerNormType.GroupNorm"><code class="docutils literal notranslate"><span class="pre">LayerNormType.GroupNorm</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.LayerNormType.LayerNorm"><code class="docutils literal notranslate"><span class="pre">LayerNormType.LayerNorm</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.LayerNormType.RmsNorm"><code class="docutils literal notranslate"><span class="pre">LayerNormType.RmsNorm</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.alibi"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.alibi</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.alibi_with_scale"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.alibi_with_scale</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.choices"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.choices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.is_alibi"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.is_alibi()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.is_rope"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.is_rope()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.learned_absolute"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.learned_absolute</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.relative"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.relative</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.rope_gpt_neox"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.rope_gpt_neox</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType.rope_gptj"><code class="docutils literal notranslate"><span class="pre">PositionEmbeddingType.rope_gptj</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.RotaryScalingType"><code class="docutils literal notranslate"><span class="pre">RotaryScalingType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.RotaryScalingType.dynamic"><code class="docutils literal notranslate"><span class="pre">RotaryScalingType.dynamic</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.RotaryScalingType.linear"><code class="docutils literal notranslate"><span class="pre">RotaryScalingType.linear</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.RotaryScalingType.none"><code class="docutils literal notranslate"><span class="pre">RotaryScalingType.none</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.Tensor"><code class="docutils literal notranslate"><span class="pre">Tensor</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.abs"><code class="docutils literal notranslate"><span class="pre">Tensor.abs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.cast"><code class="docutils literal notranslate"><span class="pre">Tensor.cast()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.dtype"><code class="docutils literal notranslate"><span class="pre">Tensor.dtype</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.get_parent"><code class="docutils literal notranslate"><span class="pre">Tensor.get_parent()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.get_users"><code class="docutils literal notranslate"><span class="pre">Tensor.get_users()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.is_dynamic"><code class="docutils literal notranslate"><span class="pre">Tensor.is_dynamic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.is_trt_wrapper"><code class="docutils literal notranslate"><span class="pre">Tensor.is_trt_wrapper()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.location"><code class="docutils literal notranslate"><span class="pre">Tensor.location</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.mark_output"><code class="docutils literal notranslate"><span class="pre">Tensor.mark_output()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.max"><code class="docutils literal notranslate"><span class="pre">Tensor.max()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.mean"><code class="docutils literal notranslate"><span class="pre">Tensor.mean()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.name"><code class="docutils literal notranslate"><span class="pre">Tensor.name</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.ndim"><code class="docutils literal notranslate"><span class="pre">Tensor.ndim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.permute"><code class="docutils literal notranslate"><span class="pre">Tensor.permute()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.rank"><code class="docutils literal notranslate"><span class="pre">Tensor.rank()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.replace_all_uses_with"><code class="docutils literal notranslate"><span class="pre">Tensor.replace_all_uses_with()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.shape"><code class="docutils literal notranslate"><span class="pre">Tensor.shape</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.size"><code class="docutils literal notranslate"><span class="pre">Tensor.size()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.split"><code class="docutils literal notranslate"><span class="pre">Tensor.split()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.sqrt"><code class="docutils literal notranslate"><span class="pre">Tensor.sqrt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.transpose"><code class="docutils literal notranslate"><span class="pre">Tensor.transpose()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tensorrt_llm.functional.Tensor.view"><code class="docutils literal notranslate"><span class="pre">Tensor.view()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.abs"><code class="docutils literal notranslate"><span class="pre">abs()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.activation"><code class="docutils literal notranslate"><span class="pre">activation()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.add"><code class="docutils literal notranslate"><span class="pre">add()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.allgather"><code class="docutils literal notranslate"><span class="pre">allgather()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.allreduce"><code class="docutils literal notranslate"><span class="pre">allreduce()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.arange"><code class="docutils literal notranslate"><span class="pre">arange()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.argmax"><code class="docutils literal notranslate"><span class="pre">argmax()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.assertion"><code class="docutils literal notranslate"><span class="pre">assertion()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.avg_pool2d"><code class="docutils literal notranslate"><span class="pre">avg_pool2d()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.bert_attention"><code class="docutils literal notranslate"><span class="pre">bert_attention()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.broadcast_helper"><code class="docutils literal notranslate"><span class="pre">broadcast_helper()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.cast"><code class="docutils literal notranslate"><span class="pre">cast()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.chunk"><code class="docutils literal notranslate"><span class="pre">chunk()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.clip"><code class="docutils literal notranslate"><span class="pre">clip()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.concat"><code class="docutils literal notranslate"><span class="pre">concat()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.constant"><code class="docutils literal notranslate"><span class="pre">constant()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.constant_to_tensor_"><code class="docutils literal notranslate"><span class="pre">constant_to_tensor_()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.conv2d"><code class="docutils literal notranslate"><span class="pre">conv2d()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.conv_transpose2d"><code class="docutils literal notranslate"><span class="pre">conv_transpose2d()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.cos"><code class="docutils literal notranslate"><span class="pre">cos()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.div"><code class="docutils literal notranslate"><span class="pre">div()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.einsum"><code class="docutils literal notranslate"><span class="pre">einsum()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.elementwise_binary"><code class="docutils literal notranslate"><span class="pre">elementwise_binary()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.embedding"><code class="docutils literal notranslate"><span class="pre">embedding()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.eq"><code class="docutils literal notranslate"><span class="pre">eq()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.exp"><code class="docutils literal notranslate"><span class="pre">exp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.expand"><code class="docutils literal notranslate"><span class="pre">expand()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.expand_dims"><code class="docutils literal notranslate"><span class="pre">expand_dims()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.expand_dims_like"><code class="docutils literal notranslate"><span class="pre">expand_dims_like()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.expand_mask"><code class="docutils literal notranslate"><span class="pre">expand_mask()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.flip"><code class="docutils literal notranslate"><span class="pre">flip()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.gather"><code class="docutils literal notranslate"><span class="pre">gather()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.gather_last_token_logits"><code class="docutils literal notranslate"><span class="pre">gather_last_token_logits()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.geglu"><code class="docutils literal notranslate"><span class="pre">geglu()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.gelu"><code class="docutils literal notranslate"><span class="pre">gelu()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.generate_alibi_biases"><code class="docutils literal notranslate"><span class="pre">generate_alibi_biases()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.generate_alibi_slopes"><code class="docutils literal notranslate"><span class="pre">generate_alibi_slopes()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.gpt_attention"><code class="docutils literal notranslate"><span class="pre">gpt_attention()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.group_norm"><code class="docutils literal notranslate"><span class="pre">group_norm()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.gt"><code class="docutils literal notranslate"><span class="pre">gt()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.identity"><code class="docutils literal notranslate"><span class="pre">identity()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.index_select"><code class="docutils literal notranslate"><span class="pre">index_select()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.interpolate"><code class="docutils literal notranslate"><span class="pre">interpolate()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.is_gated_activation"><code class="docutils literal notranslate"><span class="pre">is_gated_activation()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.layer_norm"><code class="docutils literal notranslate"><span class="pre">layer_norm()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.lt"><code class="docutils literal notranslate"><span class="pre">lt()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.matmul"><code class="docutils literal notranslate"><span class="pre">matmul()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.max"><code class="docutils literal notranslate"><span class="pre">max()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.maximum"><code class="docutils literal notranslate"><span class="pre">maximum()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.mean"><code class="docutils literal notranslate"><span class="pre">mean()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.minimum"><code class="docutils literal notranslate"><span class="pre">minimum()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.mul"><code class="docutils literal notranslate"><span class="pre">mul()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.non_gated_version"><code class="docutils literal notranslate"><span class="pre">non_gated_version()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.op_and"><code class="docutils literal notranslate"><span class="pre">op_and()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.op_or"><code class="docutils literal notranslate"><span class="pre">op_or()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.outer"><code class="docutils literal notranslate"><span class="pre">outer()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.permute"><code class="docutils literal notranslate"><span class="pre">permute()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.pow"><code class="docutils literal notranslate"><span class="pre">pow()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.recv"><code class="docutils literal notranslate"><span class="pre">recv()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.relu"><code class="docutils literal notranslate"><span class="pre">relu()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.rms_norm"><code class="docutils literal notranslate"><span class="pre">rms_norm()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.round"><code class="docutils literal notranslate"><span class="pre">round()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.select"><code class="docutils literal notranslate"><span class="pre">select()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.send"><code class="docutils literal notranslate"><span class="pre">send()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.shape"><code class="docutils literal notranslate"><span class="pre">shape()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.sigmoid"><code class="docutils literal notranslate"><span class="pre">sigmoid()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.silu"><code class="docutils literal notranslate"><span class="pre">silu()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.sin"><code class="docutils literal notranslate"><span class="pre">sin()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.slice"><code class="docutils literal notranslate"><span class="pre">slice()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.softmax"><code class="docutils literal notranslate"><span class="pre">softmax()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.softplus"><code class="docutils literal notranslate"><span class="pre">softplus()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.sqrt"><code class="docutils literal notranslate"><span class="pre">sqrt()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.squared_relu"><code class="docutils literal notranslate"><span class="pre">squared_relu()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.sub"><code class="docutils literal notranslate"><span class="pre">sub()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.swiglu"><code class="docutils literal notranslate"><span class="pre">swiglu()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.tanh"><code class="docutils literal notranslate"><span class="pre">tanh()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.transpose"><code class="docutils literal notranslate"><span class="pre">transpose()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.unary"><code class="docutils literal notranslate"><span class="pre">unary()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.unsqueeze"><code class="docutils literal notranslate"><span class="pre">unsqueeze()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.view"><code class="docutils literal notranslate"><span class="pre">view()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensorrt_llm.functional.where"><code class="docutils literal notranslate"><span class="pre">where()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tensorrt_llm.models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensorrt_llm.plugin.html">Plugin</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensorrt_llm.quantization.html">Quantization</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensorrt_llm.runtime.html">Runtime</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">C++ API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_cpp_gen/runtime.html">Runtime</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">tensorrt_llm</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Functionals</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/python-api/tensorrt_llm.functional.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-tensorrt_llm">
<span id="functionals"></span><h1>Functionals<a class="headerlink" href="#module-tensorrt_llm" title="Permalink to this heading"></a></h1>
<span class="target" id="module-tensorrt_llm.functional"></span><dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AllReduceStrategy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">AllReduceStrategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#AllReduceStrategy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.AllReduceStrategy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></p>
<dl class="simple">
<dt>Warning: actual definition is in cpp/tensorrt_llm/kernels/customAllReduceKernels.h</dt><dd><p>they must be kept in sync</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AllReduceStrategy.AUTO">
<span class="sig-name descname"><span class="pre">AUTO</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#tensorrt_llm.functional.AllReduceStrategy.AUTO" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AllReduceStrategy.ONESHOT">
<span class="sig-name descname"><span class="pre">ONESHOT</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#tensorrt_llm.functional.AllReduceStrategy.ONESHOT" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AllReduceStrategy.RING">
<span class="sig-name descname"><span class="pre">RING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#tensorrt_llm.functional.AllReduceStrategy.RING" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AllReduceStrategy.TWOSHOT">
<span class="sig-name descname"><span class="pre">TWOSHOT</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#tensorrt_llm.functional.AllReduceStrategy.TWOSHOT" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AttentionMaskType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">AttentionMaskType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#AttentionMaskType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.AttentionMaskType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AttentionMaskType.bidirectional">
<span class="sig-name descname"><span class="pre">bidirectional</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#tensorrt_llm.functional.AttentionMaskType.bidirectional" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AttentionMaskType.causal">
<span class="sig-name descname"><span class="pre">causal</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#tensorrt_llm.functional.AttentionMaskType.causal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.AttentionMaskType.padding">
<span class="sig-name descname"><span class="pre">padding</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#tensorrt_llm.functional.AttentionMaskType.padding" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.DimRange">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">DimRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#DimRange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.DimRange" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>One DimRange object stores the ranges of all the dimensions of one tensor in one optimization profile.
For example, tensor has 2 dimensions. Then the data members are:</p>
<blockquote>
<div><p>self.min = [dim 0 min, dim 1 min]
self.opt = [dim 0 opt, dim 1 opt]
self.max = [dim 0 max, dim 1 max]</p>
</div></blockquote>
<p>For static dimension, it has min==opt==max, thus the p shape param in the ctor can be an integer</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.LayerNormPositionType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">LayerNormPositionType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#LayerNormPositionType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.LayerNormPositionType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.LayerNormPositionType.post_layernorm">
<span class="sig-name descname"><span class="pre">post_layernorm</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#tensorrt_llm.functional.LayerNormPositionType.post_layernorm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.LayerNormPositionType.pre_layernorm">
<span class="sig-name descname"><span class="pre">pre_layernorm</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#tensorrt_llm.functional.LayerNormPositionType.pre_layernorm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.LayerNormType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">LayerNormType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#LayerNormType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.LayerNormType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.LayerNormType.GroupNorm">
<span class="sig-name descname"><span class="pre">GroupNorm</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#tensorrt_llm.functional.LayerNormType.GroupNorm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.LayerNormType.LayerNorm">
<span class="sig-name descname"><span class="pre">LayerNorm</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#tensorrt_llm.functional.LayerNormType.LayerNorm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.LayerNormType.RmsNorm">
<span class="sig-name descname"><span class="pre">RmsNorm</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#tensorrt_llm.functional.LayerNormType.RmsNorm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">PositionEmbeddingType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#PositionEmbeddingType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.alibi">
<span class="sig-name descname"><span class="pre">alibi</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.alibi" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.alibi_with_scale">
<span class="sig-name descname"><span class="pre">alibi_with_scale</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></em><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.alibi_with_scale" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.choices">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">choices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#PositionEmbeddingType.choices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.choices" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.is_alibi">
<span class="sig-name descname"><span class="pre">is_alibi</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#PositionEmbeddingType.is_alibi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.is_alibi" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.is_rope">
<span class="sig-name descname"><span class="pre">is_rope</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#PositionEmbeddingType.is_rope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.is_rope" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.learned_absolute">
<span class="sig-name descname"><span class="pre">learned_absolute</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.learned_absolute" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.relative">
<span class="sig-name descname"><span class="pre">relative</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">5</span></em><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.relative" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.rope_gpt_neox">
<span class="sig-name descname"><span class="pre">rope_gpt_neox</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.rope_gpt_neox" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.PositionEmbeddingType.rope_gptj">
<span class="sig-name descname"><span class="pre">rope_gptj</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#tensorrt_llm.functional.PositionEmbeddingType.rope_gptj" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.RotaryScalingType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">RotaryScalingType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#RotaryScalingType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.RotaryScalingType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.RotaryScalingType.dynamic">
<span class="sig-name descname"><span class="pre">dynamic</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#tensorrt_llm.functional.RotaryScalingType.dynamic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.RotaryScalingType.linear">
<span class="sig-name descname"><span class="pre">linear</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#tensorrt_llm.functional.RotaryScalingType.linear" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tensorrt_llm.functional.RotaryScalingType.none">
<span class="sig-name descname"><span class="pre">none</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#tensorrt_llm.functional.RotaryScalingType.none" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">Tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_range=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_network_input=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location=&lt;TensorLocation.DEVICE:</span> <span class="pre">0&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trt_tensor=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The class to represent dense tensors.</p>
<p>A dense tensor is named, has a shape and contains typed elements. Each
dimension of a tensor can either be static or dynamic. Static dimensions
are known at engine compilation by TensorRT. Dynamic dimensions can take
values determined at runtime. The tensor can be located on the host (CPU)
or the device (GPU).</p>
<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.abs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.abs" title="Permalink to this definition"></a></dt>
<dd><p>See functional.abs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.cast">
<span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.cast"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.cast" title="Permalink to this definition"></a></dt>
<dd><p>See functional.cast.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#tensorrt_llm.functional.Tensor.dtype" title="Permalink to this definition"></a></dt>
<dd><p>The type of the elements in the tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.get_parent">
<span class="sig-name descname"><span class="pre">get_parent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.get_parent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.get_parent" title="Permalink to this definition"></a></dt>
<dd><p>Get the layer that produces this tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.get_users">
<span class="sig-name descname"><span class="pre">get_users</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.get_users"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.get_users" title="Permalink to this definition"></a></dt>
<dd><p>Get the layers that use this tensor as an input.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.is_dynamic">
<span class="sig-name descname"><span class="pre">is_dynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.is_dynamic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.is_dynamic" title="Permalink to this definition"></a></dt>
<dd><p>If the argument ‘dim’ is None, that function returns a boolean that
indicates if the tensor contains a dynamic dimension (True) or not
(False). In that case, the first dimension is excluded (as it usually
corresponds to the batch size).  If the argument is an integer, that
functions returns a boolean that indicates if the dimension ‘dim’ is
dynamic (True) or not (False).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.is_trt_wrapper">
<span class="sig-name descname"><span class="pre">is_trt_wrapper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.is_trt_wrapper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.is_trt_wrapper" title="Permalink to this definition"></a></dt>
<dd><p>Check if there is a trt.ITensor member inside, which is required for
graph rewriter. In order to differentiate usages, it may be necessary
to have an inheritance hierarachy.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">location</span></span><a class="headerlink" href="#tensorrt_llm.functional.Tensor.location" title="Permalink to this definition"></a></dt>
<dd><p>The physical location of the tensor (on the host or the device).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.mark_output">
<span class="sig-name descname"><span class="pre">mark_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.mark_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.mark_output" title="Permalink to this definition"></a></dt>
<dd><p>Mark a tensor as a network output.</p>
<p>When a tensor is marked as an output, its content can be obtained after
the execution of the TensorRT engine. The user is responsible for
allocating buffers to store the output tensors when preparing the
execution of the TensorRT engine.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.max"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.max" title="Permalink to this definition"></a></dt>
<dd><p>See functional.max.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.mean" title="Permalink to this definition"></a></dt>
<dd><p>See functional.mean.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#tensorrt_llm.functional.Tensor.name" title="Permalink to this definition"></a></dt>
<dd><p>The name of the tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.ndim">
<span class="sig-name descname"><span class="pre">ndim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.ndim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.ndim" title="Permalink to this definition"></a></dt>
<dd><p>Returns the rank (i.e. the number of dimensions) of the tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.permute">
<span class="sig-name descname"><span class="pre">permute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.permute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.permute" title="Permalink to this definition"></a></dt>
<dd><p>See functional.permute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.rank">
<span class="sig-name descname"><span class="pre">rank</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.rank"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.rank" title="Permalink to this definition"></a></dt>
<dd><p>Returns the rank (i.e. the number of dimensions) of the tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.replace_all_uses_with">
<span class="sig-name descname"><span class="pre">replace_all_uses_with</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.replace_all_uses_with"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.replace_all_uses_with" title="Permalink to this definition"></a></dt>
<dd><p>Replace all uses of this tensor as an input to consumer layers</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#tensorrt_llm.functional.Tensor.shape" title="Permalink to this definition"></a></dt>
<dd><p>The shape of the tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.size" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shape of the tensor if the dim parameter is None.
Otherwise, returns a size of the dimension indicated by dim. The
behavior is undefined if dim is negative or exceeds the rank of the
tensor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">split_size_or_sections</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.split" title="Permalink to this definition"></a></dt>
<dd><p>See functional.split.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.sqrt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.sqrt" title="Permalink to this definition"></a></dt>
<dd><p>See functional.sqrt.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.transpose">
<span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.transpose" title="Permalink to this definition"></a></dt>
<dd><p>See functional.transpose.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorrt_llm.functional.Tensor.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_is_placeholder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#Tensor.view"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.Tensor.view" title="Permalink to this definition"></a></dt>
<dd><p>See functional.view.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.abs">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.UnaryOperation</span> <span class="pre">=</span> <span class="pre">&lt;UnaryOperation.ABS:</span> <span class="pre">4&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.abs" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation on a single input.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>round   for op=trt.UnaryOperation.ROUND
sqrt    for op=trt.UnaryOperation.SQRT
exp     for op=trt.UnaryOperation.EXP
sin     for op=trt.UnaryOperation.SIN
cos     for op=trt.UnaryOperation.COS
abs     for op=trt.UnaryOperation.ABS</p>
</div></blockquote>
<p>It is implemented using the IUnaryLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>op</strong> – trt.UnaryOperation
The unary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.activation">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">activation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ActivationType</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#activation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.activation" title="Permalink to this definition"></a></dt>
<dd><p>Add an activation function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p></li>
<li><p><strong>act_type</strong> – trt.ActivationType
The type of the activation (RELU, TANH, SIGMOID, …).</p></li>
</ul>
</dd>
</dl>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>relu    for op=trt.ActivationType.RELU
tanh    for op=trt.ActivationType.TANH
sigmoid for op=trt.ActivationType.SIGMOID</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.add">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.SUM:</span> <span class="pre">0&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.add" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.allgather">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">allgather</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#allgather"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.allgather" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that performs a collective all-gather.</p>
<p>Let’s define ‘world_size’ as the length of the ‘group’ list. That functions
creates a layer to gather ‘world_size’ tensors distributed
amongst the ‘world_size’ participating ranks (one GPU per rank).</p>
<p>The list ‘group’ contains the identifiers of the ranks participating into
the collective operation.</p>
<p>The tensors in the different ranks must be 1D tensors (or views) and the
output tensor will have that same shape.</p>
<p>Given the ‘section_size = input.shape[0] / world_size’, each rank
contributes a section of its input tensor that correspond to
‘rank*section_size:(rank+1)*section_size’.</p>
<p>That operation is implemented using a plugin that wraps the NCCL all-gather
collective operation. See
<a class="reference external" href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/collectives.html#allgather">https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/collectives.html#allgather</a>
for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>group</strong> – List[int]
The ranks participating into the all-gather operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by that layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.allreduce">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">allreduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">workspace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.AllReduceStrategy" title="tensorrt_llm.functional.AllReduceStrategy"><span class="pre">AllReduceStrategy</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#allreduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.allreduce" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that performs a collective all-reduce.</p>
<p>Let’s define ‘world_size’ as the length of the ‘group’ list. That functions
creates a layer to compute the sum of ‘world_size’ tensors distributed
amongst the ‘world_size’ participating ranks (one GPU per rank).</p>
<p>The list ‘group’ contains the identifiers of the ranks participating into
the collective operation.</p>
<p>The tensors in the different ranks must be 1D tensors (or views) and the output
tensor will have that same shape. The output tensor will be replicated on
the ‘world_size’ ranks.</p>
<p>That operation is implemented using a plugin that wraps the NCCL all-reduce
collective operation. See
<a class="reference external" href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/collectives.html#allreduce">https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/collectives.html#allreduce</a>
for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>group</strong> – List[int]
The ranks participating into the all-reduce operation.</p></li>
<li><p><strong>workspace</strong> – Optional[Tensor]
When using CUSTOM or AUTO mode, a tensor containing pointers to memory
visible to all GPUs. It should be 3 poitners per TP rank -
ptr to data buffer, ptr to barriers in, ptr to barriers out.
It must be initilized using IpcMemory class.</p></li>
<li><p><strong>instance_id</strong> – int
Used for synchronization with CUSTOM or AUTO. Corresponding plugins MUST have the same
instance_id. I.e. GPU#0’s allreduce after MLP at layer i must have the same instance_id as
GPU#1, GPU#2… Also, instance_id MUST be unique per model. There should be two allreduce instance
in GPU#0 that have the same id.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by that layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.arange">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">arange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#arange"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.arange" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to fill a 1D tensor.</p>
<p>The tensor is filled with the values between start and end with a step of 1
between the different elements. In pseudo-code, it corresponds to a tensor
populated with the values:</p>
<blockquote>
<div><p>output = Tensor([dtype(ii) for ii in range(start, end, 1)])</p>
</div></blockquote>
<p>For example, a call to arange(3, 6, ‘int32’) will add an operation to the
TensorRT graph that will produce [3, 4, 5] when executed. The call to
arange(2, 5, ‘float32’) will add a layer to generate [2.0, 3.0, 4.0].</p>
<p>This operation is implemented using a tensorrt.IFillLayer in
trt.FillOperation.LINSPACE mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Union[Tensor, int]
The starting point of the range.</p></li>
<li><p><strong>end</strong> – Union[Tensor, int]
The end point of the range.</p></li>
<li><p><strong>dtype</strong> – str
The type of the elements. See _str_to_trt_dtype_dict in _utils.py
for a list of supported types and type names.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the fill layer. It is a 1D tensor containing
<cite>end-start</cite> elements of type <cite>dtype</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.argmax">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">argmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#argmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.argmax" title="Permalink to this definition"></a></dt>
<dd><p>Add an argmax operation.</p>
<p>As explained in the ONNX documentation,</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/onnx/onnx/blob/main/docs/Operators.md#argmax">https://github.com/onnx/onnx/blob/main/docs/Operators.md#argmax</a></p>
</div></blockquote>
<p>that function creates a layer computing the indices of the max elements of
the input tensor’s element along the provided dim. The resulting tensor
has the same rank as the input if keepdims is True. If keepdims is False,
then the resulting tensor has the reduced dimension pruned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>dim</strong> – int
The dimension in which to compute the argmax indices.</p></li>
<li><p><strong>keepdim</strong> – bool
Do we keep the dimension along which the reduction is performed?
Yes, if set to True, no otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this argmax operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.assertion">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">assertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#assertion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.assertion" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.avg_pool2d">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">avg_pool2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ceil_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count_include_pad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#avg_pool2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.avg_pool2d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.bert_attention">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">bert_attention</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_lengths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_heads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">head_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_attention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_attention_bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#bert_attention"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.bert_attention" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that performs the multi-head attention in BERT.</p>
<p>The multihead-attention (MHA) is the sequence of a batched matmul, a
softmax and a batched matmul as described in
<a class="reference external" href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a>. That function adds an operation that
performs those computations using a single GPU kernel.</p>
<p>The input tensor contains the Q, K and V elements. It is a 2D tensor and
its shape is ‘[sum_of_tokens, 3*hidden_dim]’ where the ‘sum_of_tokens’ is
the sum of the sequence lengths in the batch.</p>
<p>In MHA, the output of the Q*K^T product is scaled by a constant value that
is computed as:</p>
<blockquote>
<div><p>1.f / (q_scaling * sqrt(head_size)).</p>
</div></blockquote>
<p>That ‘q_scaling’ constant is the last argument of that function.</p>
<p>That layer is implemented using a plugin (see bertAttentionPlugin).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The QKV input tensor.</p></li>
<li><p><strong>input_lengths</strong> – Tensor
The length of each sequence. It is a 1D tensor of size ‘batch_size’.</p></li>
<li><p><strong>num_heads</strong> – int
The number of heads.</p></li>
<li><p><strong>head_size</strong> – int
The size of each head.</p></li>
<li><p><strong>q_scaling</strong> – float
The factor to compute the scaling factor to scale the output of the
‘Q*K^T’ product.</p></li>
<li><p><strong>relative_attention</strong> – bool = False
If enable relative attention.</p></li>
<li><p><strong>relative_attention_bias</strong> – Tensor = None
The relative attention bias [num_heads, max_seq_len, max_seq_len], or The relative attention embedding table for implicit mode, [num_heads, num_buckets].</p></li>
<li><p><strong>max_distance</strong> – int = 0
The maximum distance of relative position in attention, for implicit mode.
Default value is 0, meaning to use the regular mode of relative attention bias.
Implicit mode is only enabled when passing in non-zero positive max_distance value.
See relative attention bias in docs/gpt_attention.md</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by that layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.broadcast_helper">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">broadcast_helper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#broadcast_helper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.broadcast_helper" title="Permalink to this definition"></a></dt>
<dd><p>Helper function to perform a broadcast.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair of tensors of same rank.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.cast">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">DataType</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#cast"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.cast" title="Permalink to this definition"></a></dt>
<dd><p>Add a cast operation.</p>
<p>For an input tensor of type INT8, this function sets the dynamic range of
the input to [-127, 127] for automatic dequantization. For a cast into
INT8, that function sets the dynamic range of the output to [-127, 127] for
automatic quantization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the cast is applied.</p></li>
<li><p><strong>dtype</strong> – str or trt.DataType
The data type of the output tensor after the cast. When ‘dtype’ is
provided as a string, it must be a name amongst the valid names.
See _str_to_trt_dtype_dict in _utils.py for a list of supported
types and type names.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the inserted layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.chunk">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">chunk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#chunk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.chunk" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that splits a tensor into sub-tensors.</p>
<p>This operation creates a list of tensors that are obtained from the input
tensor by chunking it along the dimension ‘dim’. It produces ‘chunks’
sub-tensors.</p>
<p>That operation is only defined for static tensors (no dynamic dimension)
and the size of the tensor in the dimension ‘dim’ must be a multiple of
‘chunks’: ‘input.shape[dim] % chunks == 0’.</p>
<p>It maps to ‘split’ with ‘split_size = input.shape[dim] / chunks’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The input tensor to slice.</p></li>
<li><p><strong>chunks</strong> – int
The number of slices to split the input tensor into.</p></li>
<li><p><strong>dim</strong> – int
The dimension of the tensor to slice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of tensors produced by the different operations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.clip">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">clip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#clip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.clip" title="Permalink to this definition"></a></dt>
<dd><p>Add a CLIP operation that sets the range to [alpha, beta].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p></li>
<li><p><strong>alpha</strong> – float
The lower bound of the CLIP function.</p></li>
<li><p><strong>beta</strong> – float
The upper bound of the CLIP function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.concat">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.concat" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to concatenate tensors.</p>
<p>The function creates an operation that concatenates the tensors from the
sequence ‘inputs’. The concatenation is done along the dimension ‘dim’.</p>
<p>All the tensors in ‘inputs’ must have the same shape expect for the
dimension ‘dim’.</p>
<blockquote>
<div><dl class="simple">
<dt>for ii in range(inputs[0].rank()):</dt><dd><p>assert (ii == dim) or all(inp.shape[ii] == inputs[0].shape[ii] for inp in inputs)</p>
</dd>
</dl>
</div></blockquote>
<p>The shape of the output tensor is defined as:</p>
<blockquote>
<div><dl>
<dt>for ii in range(inputs[0].rank()):</dt><dd><p># Same size as all the inputs in dimension ii != dim.
output.shape[ii] = inputs[0].shape[ii]</p>
<p># Sum of the sizes in the different inputs in dimension ‘dim’.
if ii == dim:</p>
<blockquote>
<div><dl class="simple">
<dt>for jj in range(1, len(inputs)):</dt><dd><p>output.shape[ii] += inputs[jj].shape[ii]</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>For example, given a sequence of two 2D tensors [[0, 1], [2, 3]] and
[[4, 5], [6, 7]] both of shape [2, 2],</p>
<blockquote>
<div><p>concat(inputs, 0)</p>
</div></blockquote>
<p>will produce [[[0, 1], [2, 3]], [[4, 5], [6, 7]]] of shape [4, 2] and</p>
<blockquote>
<div><p>concat(inputs, 1)</p>
</div></blockquote>
<p>will produce [[0, 1, 4, 5], [2, 3, 6, 7]] of shape [2, 4].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> – Sequence[Union[Tensor, int]]
The sequence of tensors to concatenate. For integers, that function
creates constant tensors.</p></li>
<li><p><strong>dim</strong> – int
The dimension in which the concatenation is performed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor that contains the concatenation of the tensors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.constant">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ndarray</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#constant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.constant" title="Permalink to this definition"></a></dt>
<dd><p>Add a constant layer.</p>
<p>TensorRT graphs encapsulate constant values in the form of constant layers
(tensorrt.IConstantLayer). That function creates such a layer from a Numpy
array of values. After compilation of the network by TensorRT, those
weights are stored in the serialized TensorRT engine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ndarray</strong> – numpy.ndarray
The array of values (weights) encapsulated by this constant layer.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the inserted layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.constant_to_tensor_">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">constant_to_tensor_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype:</span> <span class="pre">~tensorrt.tensorrt.DataType</span> <span class="pre">=</span> <span class="pre">&lt;DataType.FLOAT:</span> <span class="pre">0&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#constant_to_tensor_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.constant_to_tensor_" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.conv2d">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">conv2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#conv2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.conv2d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.conv_transpose2d">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">conv_transpose2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#conv_transpose2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.conv_transpose2d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.cos">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.UnaryOperation</span> <span class="pre">=</span> <span class="pre">&lt;UnaryOperation.COS:</span> <span class="pre">7&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.cos" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation on a single input.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>round   for op=trt.UnaryOperation.ROUND
sqrt    for op=trt.UnaryOperation.SQRT
exp     for op=trt.UnaryOperation.EXP
sin     for op=trt.UnaryOperation.SIN
cos     for op=trt.UnaryOperation.COS
abs     for op=trt.UnaryOperation.ABS</p>
</div></blockquote>
<p>It is implemented using the IUnaryLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>op</strong> – trt.UnaryOperation
The unary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.div">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.DIV:</span> <span class="pre">5&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.div" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.einsum">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">einsum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">einsum_eq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#einsum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.einsum" title="Permalink to this definition"></a></dt>
<dd><p>Add an Einsum operation.</p>
<p>That operation maps to tensorrt.IEinsumLayer. As explained in the TensorRT
documentation, this layer implements a summation over the elements of the
inputs along dimensions specified by the equation parameter, based on the
Einstein summation convention. The layer can have one or more inputs of
rank &gt;= 0.  All the inputs must be of same data type. This layer supports
all TensorRT data types except bool. There is one output tensor of the same
type as the input tensors. The shape of output tensor is determined by the
equation.</p>
<p>The equation specifies ASCII lower-case letters for each dimension in the
inputs in the same order as the dimensions, separated by comma for each
input. The dimensions labeled with the same subscript must match or be
broadcastable. Repeated subscript labels in one input take the diagonal.
Repeating a label across multiple inputs means that those axes will be
multiplied. Omitting a label from the output means values along those axes
will be summed. In implicit mode, the indices which appear once in the
expression will be part of the output in increasing alphabetical order. In
explicit mode, the output can be controlled by specifying output subscript
labels by adding an arrow (‘-&gt;’) followed by subscripts for the output. For
example, “ij,jk-&gt;ik” is equivalent to “ij,jk”. Ellipsis (‘…’) can be used
in place of subscripts to broadcast the dimensions. See the TensorRT
Developer Guide for more details on equation syntax.</p>
<p>Many common operations can be expressed using the Einsum equation. For
.. rubric:: Example</p>
<p>Matrix Transpose: ij-&gt;ji
Sum: ij-&gt; Matrix-Matrix
Multiplication: ik,kj-&gt;ij
Dot Product: i,i-&gt;
Matrix-Vector Multiplication: ik,k-&gt;i
Batch Matrix Multiplication: ijk,ikl-&gt;ijl
Batch Diagonal: …ii-&gt;…i</p>
<p>Note that TensorRT does not support ellipsis or diagonal operations so,
neither, does TensorRT-LLM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>einsum_eq</strong> – str
The Einsum equation.</p></li>
<li><p><strong>inputs</strong> – Sequence[Tensor]
The sequence of inputs consumed by the Einsum operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the Einsum operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.elementwise_binary">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">elementwise_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ElementWiseOperation</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#elementwise_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.elementwise_binary" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.embedding">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sharding_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to perform embedding lookup.</p>
<p>That operation performs the embedding lookup. The ‘input’ tensor contains
the identifiers of the rows of ‘weight’ to gather.</p>
<p>1. Distribute the embedding lookup table over multiple GPU
When ‘tp_size’ is greater than 1 and the ‘tp_group’ is defined, this
embedding lookup is distributed among multiple GPUs.</p>
<p>When ‘sharding_dim==0’, each GPU stores a subset of the rows of the embedding
table rows(that number of rows per GPU is given by weights.shape[0] and the offset to
the 1st row stored on the GPU is given by rank * weights.shape[0]). Each
parallel rank will query all the indices and set 0s for the weights that
are not stored on the associated GPU. To compute the final result, a
parallel all-reduce operation is added to the TensorRT graph. That lookup
can be performed using either the plugin or the operators TensorRT support.</p>
<p>When’sharding_dim==1’, each GPU stores a subset of the embedding table’s columns.
Each rank can obtain a portion of the embedding results.
Then the embedding is collected using the  all-gather operation.
Related transposition operations are also used to obtain the final results.</p>
<p>2. Store embedding lookup table as a whole
When ‘tp_size’ is not greater than 1, the embedding lookup table will not
be divided. In this case, when the default_net().plugin_config.lookup_plugin is set,
the operation is implemented using a plugin (without the all-reduce operation).
Otherwise, this operation is implemented using the standard IGatherLayer in TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor the contains the indices to perform the lookup.</p></li>
<li><p><strong>weight</strong> – Tensor
The table to gather from.</p></li>
<li><p><strong>tp_size</strong> – int
The number of GPUs collaborating to perform that embedding.</p></li>
<li><p><strong>tg_group</strong> – Optional[List[int]]
The group of world ranks participating in the all-reduce when
tp_size &gt; 1.</p></li>
<li><p><strong>sharding_dim</strong> – int
sharding_dim = 0 means that we shard the embedding table in vocab dim;
sharding_dim = 1 means that we shard the embedding table in embedding dim.</p></li>
<li><p><strong>tp_rank</strong> – int
The tensor parallelism rank. Used to calculate offset in TP on vocab dim.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the embedding lookup layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.eq">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.EQUAL:</span> <span class="pre">11&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.eq" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.exp">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.UnaryOperation</span> <span class="pre">=</span> <span class="pre">&lt;UnaryOperation.EXP:</span> <span class="pre">0&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.exp" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation on a single input.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>round   for op=trt.UnaryOperation.ROUND
sqrt    for op=trt.UnaryOperation.SQRT
exp     for op=trt.UnaryOperation.EXP
sin     for op=trt.UnaryOperation.SIN
cos     for op=trt.UnaryOperation.COS
abs     for op=trt.UnaryOperation.ABS</p>
</div></blockquote>
<p>It is implemented using the IUnaryLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>op</strong> – trt.UnaryOperation
The unary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.expand">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.expand" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to expand a tensor.</p>
<p>The operation expands the input tensor in the singleton dimensions to the
size indicated by the corresponding dimension in the <cite>expand_shape</cite> tensor.
In other words, given an input tensor with dimensions of size 1, those
dimensions will be expanded to the size in <cite>expand_shape</cite>.</p>
<p>For example, a tensor of shape [4, 3, 1, 3] will be expanded to a tensor of
shape [4, 3, 2, 3] by the layer created using expand(input, [4, 3, 2, 3]).</p>
<p>The expansion may either replicate the values or be mapped to a view with a
stride of 0 in the expanded dimensions. For example, for a tensor [[3, 2]] of
shape [1, 2],</p>
<blockquote>
<div><p>expand([[3, 2]], [2, 2])</p>
</div></blockquote>
<p>can be used to expand the input to [[3, 2], [3, 2]].</p>
<p>This operation is implemented using a tensorrt.ISliceLayer. The current
implementation does not verify that non singleton dimensions are not
shrinked. In other words, for an input of shape [4, 1, 2],</p>
<blockquote>
<div><p>expand(input, [3, 2, 2])</p>
</div></blockquote>
<p>will produce a tensor of shape [3, 2, 2]. That behaviour is subject to
change in the future.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>expand_shape</strong> – Tensor
The new shape of the expanded tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the expand layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.expand_dims">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">expand_dims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#expand_dims"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.expand_dims" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to expand the tensor shape with singleton dimensions.</p>
<p>That function adds a tensorrt.IShuffleLayer to the network. Given an ‘input’
of rank N and a sequence of M dimensions, the output tensor produced by
this operation (when executed by TensorRT) will have a rank of N+M. Singleton
dimensions will be inserted at the different positions in ‘dim’.</p>
<p>The pseudo-code for that operation is:</p>
<blockquote>
<div><p>new_shape, ii = [], 0
for jj in range(input.rank() + len(dim)):</p>
<blockquote>
<div><p>new_shape.append(1 if jj in dims else input.shape[ii++])</p>
</div></blockquote>
</div></blockquote>
<p>For example, for a tensor of shape [3, 4, 1, 5]</p>
<blockquote>
<div><p>expand_dims(input, [0, 2])</p>
</div></blockquote>
<p>will produce a tensor of shape [1, 3, 1, 4, 1, 5].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to expand.</p></li>
<li><p><strong>dim</strong> – Union[int, Sequence[int]]
The positions in the output tensor where to insert singleton
dimensions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the shuffle layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.expand_dims_like">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">expand_dims_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#expand_dims_like"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.expand_dims_like" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to expand the first tensor to the same rank as the second
tensor.</p>
<p>That function takes a first tensor. It also accepts an integer or a float,
in which case it creates a constant tensor from it. In both cases, the rank
of that first tensor is compared to the rank of the second tensor. If they
are of the same rank, the first tensor is returned. Otherwise, the first
tensor is expanded on the left to match the rank of the second tensor.</p>
<p>Note that the shapes do not have to match, only the rank is considered in
that function.</p>
<p>For example, for a pair of tensors of shapes [3, 4] and [4, 3, 2], the
first tensor will be expanded to a tensor of rank 3 and shape [1, 3, 4].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first tensor to expand. When a scalar value is provided as a
parameter, that function first creates a tensor before expanding it
(if needed).</p></li>
<li><p><strong>right</strong> – Tensor
The reference tensor to match.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the shuffle layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.expand_mask">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">expand_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tgt_len</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#expand_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.expand_mask" title="Permalink to this definition"></a></dt>
<dd><p>Expand an attention mask.</p>
<p>That function adds the sequence of operations to expand from a tensor of
shape ‘[batch_size, src_seq_len]’ to a tensor of shape
‘[batch_size, 1, tgt_seq_len, src_seq_len]’. It can be used to create the
mask applied to the Q*K^T product before the softmax operation in the
multihead-attention block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – Tensor
The input mask</p></li>
<li><p><strong>tgt_len</strong> – Optional[Tensor]
The dimension of the 3rd dimension in the output tensor. If None,
the 2nd dimension of the input is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor created by that sequence of operations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.flip">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#flip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.flip" title="Permalink to this definition"></a></dt>
<dd><p>Reverses the order of an n-D tensor along given axis in dims.</p>
<p>That flip operation maps to a TensorRT ISliceLayer. For the dimensions
listed in dims it copies the elements from the last one to the first one
(from (N-1) down to 0 with a step of -1). For the dimensions not in ‘dims’,
it copies the elements from the first one to the last one (from 0 to N-1
with a step of 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the cast is applied.</p></li>
<li><p><strong>dims</strong> – list or tuple
The axes to flip. Negative indices are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the inserted layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.gather">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">gather</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#gather"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.gather" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to gather elements from a tensor.</p>
<p>That function implements the GatherElements operator from the ONNX
specification as described in</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/onnx/onnx/blob/main/docs/Operators.md#GatherElements">https://github.com/onnx/onnx/blob/main/docs/Operators.md#GatherElements</a></p>
</div></blockquote>
<p>The input and indices arguments must have the same rank &gt;= 1. The operation
will produce a tensor with the same shape as the indices tensor. The axis
is the dimension to gather on.</p>
<p>As shown in the ONNX description, for a 3D tensor, the output is:</p>
<blockquote>
<div><p>out[i][j][k] = input[indices[i][j][k]][j][k] if axis = 0,
out[i][j][k] = input[i][indices[i][j][k]][k] if axis = 1,
out[i][j][k] = input[i][j][indices[i][j][k]] if axis = 2.</p>
</div></blockquote>
<p>For example,</p>
<blockquote>
<div><p>gather([[4, 2], [5, 3]], 0, [[1, 0], [0, 1]])</p>
</div></blockquote>
<p>will produce [[5, 2], [4, 3]].</p>
<blockquote>
<div><p>gather([[1, 2, 3], [4, 5, 6], 1, [[1], [0]])</p>
</div></blockquote>
<p>will produce [[2], [4]]. See the ONNX documentation for more examples.</p>
<p>That operation maps to the TensorRT IGatherLayer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to gather elements from.</p></li>
<li><p><strong>dim</strong> – int
The dimension to gather on.</p></li>
<li><p><strong>indices</strong> – Union[Tensor, int]
The positions in the ‘dim’ dimension to gather from.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor containing the gathered elements. It has the same shape as
the indices tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.gather_last_token_logits">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">gather_last_token_logits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hidden_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_token_ids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_input_padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#gather_last_token_logits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.gather_last_token_logits" title="Permalink to this definition"></a></dt>
<dd><p>Extract the logits that correspond to the last token from the hidden states.</p>
<p>That function adds the operations to extract the logits of the last tokens
in a batch of sequences.</p>
<p>Depending on whether ‘remove_input_padding’ is ‘True’ or ‘False’, that
function assumes inputs of different shapes.</p>
<p>When ‘remove_input_padding’ is ‘True’, the ‘hidden_states’ tensor is
assumed to be packed. It has a shape ‘[num_tokens, hidden_dim]’ where
‘num_tokens’ is the sum of the lengths of the sequences in the batch and
‘hidden_dim’ is the hidden dimension. The ‘last_tokens_ids’ is a 1D tensor
that encodes the inclusive prefix-sums of the lengths of the sequences in
the batch.</p>
<p>When ‘remove_input_padding’ is ‘False’, the ‘hidden_states’ tensor is
assumed to be padded. It has a shape ‘[batch_size, max_seqlen, hidden_dim]’
where ‘max_seqlen’ is the length of the longest sequence in the batch and
‘hidden_dim’ is the hidden dimension.  The ‘last_token_ids’ is a 1D tensor
that encodes the length of each sequence in the batch.</p>
<p>In both cases, that function produces a tensor of shape ‘[batch_size,
hidden_size]’ where the row at index ‘i’ corresponds to the logits of the
last token from the ‘i’-th sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hidden_states</strong> – Tensor
The hidden states</p></li>
<li><p><strong>last_token_ids</strong> – Tensor
The inclusive prefix-sum of the lengths or the lenghts of the
sequences in the batch.</p></li>
<li><p><strong>remove_input_padding</strong> – bool
Indicate if the hidden_states are packed (‘True’) or padded
(‘False’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor created by that sequence of operations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.geglu">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">geglu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#geglu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.geglu" title="Permalink to this definition"></a></dt>
<dd><p>Add a Gated-GELU operation.</p>
<p>That function takes a tensor, splits it into two halves along the last
dimension, applies GELU to the second half and multiply the results. The
behaviour is undefined if the last dimension is not even.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.gelu">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">gelu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#gelu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.gelu" title="Permalink to this definition"></a></dt>
<dd><p>Add a GELU operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.generate_alibi_biases">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">generate_alibi_biases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slopes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#generate_alibi_biases"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.generate_alibi_biases" title="Permalink to this definition"></a></dt>
<dd><p>Compute the ALiBi biases as described in <a class="reference external" href="https://arxiv.org/abs/2211.05100">https://arxiv.org/abs/2211.05100</a>.</p>
<p>The ALiBi biases are added to the result of the Q*K^T product in the
multihead-attention block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slopes</strong> – Tensor
The slopes.</p></li>
<li><p><strong>key_length</strong> – Tensor
The size of the K vector per head.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A constant tensor that contains the ALiBi biases.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.generate_alibi_slopes">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">generate_alibi_slopes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_heads:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype:</span> <span class="pre">~tensorrt.tensorrt.DataType</span> <span class="pre">=</span> <span class="pre">&lt;DataType.FLOAT:</span> <span class="pre">0&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_size:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_rank:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alibi_scale:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#generate_alibi_slopes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.generate_alibi_slopes" title="Permalink to this definition"></a></dt>
<dd><p>Compute the ALiBi slopes as described in <a class="reference external" href="https://arxiv.org/abs/2211.05100">https://arxiv.org/abs/2211.05100</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_heads</strong> – int
The number of heads.</p></li>
<li><p><strong>dtype</strong> – trt.DataType
The data type of the returned slopes</p></li>
<li><p><strong>tp_size</strong> – int
The tensor parallelism size</p></li>
<li><p><strong>tp_rank</strong> – int
The tensor parallelism rank</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A constant tensor that contains the ALiBi slopes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.gpt_attention">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">gpt_attention</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_key_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">host_past_key_value_lengths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_lengths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_indirection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">host_request_types</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_heads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_kv_heads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_size_per_head</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotary_embedding_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotary_embedding_base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotary_embedding_scale_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.RotaryScalingType" title="tensorrt_llm.functional.RotaryScalingType"><span class="pre">RotaryScalingType</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RotaryScalingType.none</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotary_embedding_scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotary_embedding_max_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position_embedding_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.PositionEmbeddingType" title="tensorrt_llm.functional.PositionEmbeddingType"><span class="pre">PositionEmbeddingType</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">PositionEmbeddingType.learned_absolute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multi_block_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kv_orig_quant_scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kv_quant_orig_scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kv_cache_quant_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="tensorrt_llm.quantization.html#tensorrt_llm.quantization.QuantMode" title="tensorrt_llm.quantization.mode.QuantMode"><span class="pre">QuantMode</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_context_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.AttentionMaskType" title="tensorrt_llm.functional.AttentionMaskType"><span class="pre">AttentionMaskType</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">AttentionMaskType.causal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alibi_slopes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kv_cache_block_pointers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_cross_attention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_qkv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_qkv_length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoder_input_lengths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_attention_bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host_context_lengths</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qkv_bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#gpt_attention"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.gpt_attention" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that performs the multi-head attention in GPT-like models.</p>
<p>The signature of the function will change in the future release - we are in
the process of simplifying the API. The current version is still
work-in-progress! The following API is provided with hints regarding the
arguments that are likely to be removed or merged with others in the future
release.</p>
<p>See docs/gpt_attention.md for the documentation of that function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The input QKV tensor. Its shape is [batch_beam_size, max_seqlen, 3
* hidden_dim] in padded mode and [1, num_tokens, 3 * hidden_dim] in
packed mode. See QKV Input in docs/gpt_attention.md.</p></li>
<li><p><strong>past_key_value</strong> – Tensor
The tensor that stores KV cache data. Its shape is
[max_batch_size * max_beam_width, 2, num_heads, max_seqlen, hidden_dim_per_head]
in contiguous mode and
[max_blocks, 2, num_heads, num_tokens_per_block, hidden_dim_per_head]
in paged mode. See KV Cache in docs/gpt_attention.md,</p></li>
<li><p><strong>sequence_lengths</strong> – Tensor
The tensor that stores the length of each sequence. Its shape is
[batch_size]. See QKV Input in docs/gpt_attention.md,</p></li>
<li><p><strong>past_key_value_length</strong> (<em>host</em>) – Tensor
An INT32 tensor of shape [batch_size].</p></li>
<li><p><strong>context_lengths</strong> – Tensor
The tensor that stores the context-phase sequence length of each request. Its shape
is [batch_size]. See QKV Input in doc/functional.py,</p></li>
<li><p><strong>cache_indirection</strong> – Tensor
The tensor to reconstruct the paths when using beam-search. Its
shape is [batch_size, beam_width, max_seqlen]. See Beam-Search in
docs/gpt_attention.md,</p></li>
<li><p><strong>host_request_types</strong> – Tensor = None
The tensor on the host that indicates if a request is in context or
generation phase. Its shape is [batch_size]. See Inflight Batching
in docs/gpt_attention.md,</p></li>
<li><p><strong>num_heads</strong> – int
The number of heads,</p></li>
<li><p><strong>num_kv_heads</strong> – int
The number of KV heads, generic to handle MHA/MQA/GQA,</p></li>
<li><p><strong>hidden_size_per_head</strong> – int
The hidden size per head,</p></li>
<li><p><strong>q_scaling</strong> – float
The value used to compute the scaling factor applied to the output
of the Q*K^T product. See Scaling Factors in docs/gpt_attention.md,</p></li>
<li><p><strong>rotary_embedding_dim</strong> – int
The dimension to compute RoPE. Use 0 when position_embedding_type is not RoPE.</p></li>
<li><p><strong>rotary_embedding_base</strong> – float
The theta value to use for RoPE. Ignored when position_embedding_type is not RoPE.</p></li>
<li><p><strong>rotary_embedding_scale_type</strong> – <p>RotaryScalingType
The scaling type of RoPE. Ignored when position_embedding_type is not RoPE.
Possible rotary scaling type:</p>
<blockquote>
<div><ul>
<li><p>RotaryScalingType.none</p></li>
<li><p>RotaryScalingType.linear</p></li>
<li><p>RotaryScalingType.dynamic</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>rotary_embedding_scale</strong> – float
The scale value to use for linear/dynamic scaling in RoPE.
Ignored when position_embedding_type is not RoPE.
Must be set to 1 (default) if rotary_embedding_scale_type is <cite>none</cite>.</p></li>
<li><p><strong>rotary_embedding_max_positions</strong> – int
Needed only for <cite>dynamic</cite> RoPE scaling. Ignored otherwise.</p></li>
<li><p><strong>position_embedding_type</strong> – <p>PositionEmbeddingType
The position embedding type:</p>
<blockquote>
<div><ul>
<li><p>PositionEmbeddingType.learned_absolute</p></li>
<li><p>PositionEmbeddingType.relative</p></li>
<li><p>PositionEmbeddingType.rope_gptj</p></li>
<li><p>PositionEmbeddingType.rope_gpt_neox</p></li>
<li><p>PositionEmbeddingType.alibi</p></li>
<li><p>PositionEmbeddingType.alibi_with_scale</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>multi_block_mode</strong> – bool
Do we enable multi-block for the masked MHA. See Generation Phase
in docs/gpt_attention.md,</p></li>
<li><p><strong>kv_orig_quant_scale</strong> – Tensor
The tensor to store the scaling factor for quantization to INT8/FP8
in the KV cache. Its shape is [1]. See INT8/FP8 KV Cache in
docs/gpt_attention.md,</p></li>
<li><p><strong>kv_quant_orig_scale</strong> – Tensor
The tensor to store the scaling factor for dequantization from
INT8/FP8 in the KV cache. Its shape is [1]. See INT8/FP8 KV Cache
in docs/gpt_attention.md,</p></li>
<li><p><strong>kv_cache_quant_mode</strong> – QuantMode (int flags)
Do we enable the INT8 or FP8 KV cache?</p></li>
<li><p><strong>max_context_length</strong> – int32_t
The length of the longest input sequence. See QKV Input in
docs/gpt_attention.md,</p></li>
<li><p><strong>mask_type</strong> – <p>int = 1
The type of mask:</p>
<blockquote>
<div><ul>
<li><p>tensorrt_llm.layers.AttentionMaskType.padding for BERT,</p></li>
<li><p>tensorrt_llm.layers.AttentionMaskType.causal for GPT,</p></li>
<li><p>tensorrt_llm.layers.AttentionMaskType.bidirectional for ChatGLM,</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>alibi_slopes</strong> – Tensor
The ALiBi slopes. The ALiBi bias is computed on-the-fly in the kernel
when possible,</p></li>
<li><p><strong>tp_size</strong> – int
The number of processes/GPUs when tensor parallelism is activated,</p></li>
<li><p><strong>tp_rank</strong> – int
The rank of that process (when running tensor parallelism),</p></li>
<li><p><strong>kv_cache_block_pointers</strong> – The tensor of block pointers for the KV cache. Its shape is
[max_batch_size, max_beam_width, 2, max_blocks_per_sequence * 2]
See KV cache section in docs/gpt_attention.md,</p></li>
<li><p><strong>do_cross_attention</strong> – bool = False
Do we use this as cross attention instead of self attention,</p></li>
<li><p><strong>cross_qkv</strong> – Tensor = None
The QKV tensor of encoder output hidden states. Its shape is [batch_size, max_seqlen, 3
* hidden_dim] in padded mode and [1, num_tokens, 3 * hidden_dim] in
packed mode,</p></li>
<li><p><strong>cross_qkv_length</strong> – Tensor = None
The length of the longest encoder output sequence,</p></li>
<li><p><strong>encoder_input_lengths</strong> – Tensor
The tensor that stores the length of each encoder input sequence. Its shape is [batch_size],</p></li>
<li><p><strong>relative_attention_bias</strong> – Tensor = None
The relative attention bias [num_heads, max_seq_len, max_seq_len], or The relative attention embedding table for implicit mode, [num_heads, num_buckets].</p></li>
<li><p><strong>max_distance</strong> – int = 0
The maximum distance of relative position in attention, for implicit mode.
Default value is 0, meaning to use the regular mode of relative attention bias.
Implicit mode is only enabled when passing in non-zero positive max_distance value.
See relative attention bias in docs/gpt_attention.md</p></li>
<li><p><strong>host_context_lengths</strong> – Tensor = None
A host tensor that contains the lengths of the different inputs,</p></li>
<li><p><strong>qkv_bias</strong> – Tensor = None,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by that layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.group_norm">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">group_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_groups</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#group_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.group_norm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.gt">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">gt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.GREATER:</span> <span class="pre">12&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.gt" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.identity">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.identity" title="Permalink to this definition"></a></dt>
<dd><p>Add an identity operation.</p>
<p>TODO: Document why it can be done using a plugin!!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> – Tensor
The input tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this identity operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.index_select">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">index_select</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#index_select"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.index_select" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to select slices of elements from a tensor.</p>
<p>Given an input tensor, that function creates an operation that selects the
slices of elements in the dimension ‘dim’ at the indices listed in ‘index’
to create a new tensor.  The output tensor has the same rank as the input
tensor.</p>
<p>The ‘index’ is a tensor of rank 1.</p>
<p>For example, on input=[[4, 2, 5], [2, 1, 2], [4, 7, 1]], which has a shape
[3, 3],</p>
<blockquote>
<div><p>index_select(input, 0, [0, 1])</p>
</div></blockquote>
<p>will create a tensor of shape [3, 2] that contains the [[4, 2, 5], [2, 1, 2]].</p>
<p>Regarding the shape of the output tensor, the dimension ‘dim’ has the same
size as the ‘index’ tensor. It means that for a tensor of shape [4, 2, 6, 3],</p>
<blockquote>
<div><p>index_select(input, 2, [1, 4])</p>
</div></blockquote>
<p>will select the 2nd and 5th slices (index == 1 or 4) from the 3rd dimension
(dim == 2) and return a tensor of shape [4, 2, 2, 3] (i.e. the 3rd
dimension is shrinked to 2).</p>
<p>Note that this operation can also be used to expand a tensor in the ‘dim’
dimension, for example, on input [[0, 1], [2, 3]],</p>
<blockquote>
<div><p>index_select(input, 1, [0, 0, 0])</p>
</div></blockquote>
<p>will produce a tensor of shape [2, 3] containing [[0, 0, 0], [2, 2, 2]].</p>
<p>That operation maps to the TensorRT IGatherLayer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to select from.</p></li>
<li><p><strong>dim</strong> – int
The dimension to select from.</p></li>
<li><p><strong>index</strong> – Tensor
The indices of the slices in the ‘dim’ dimension to select.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor containing the selected slices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.interpolate">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'nearest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">align_corners</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute_scale_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">antialias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#interpolate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.interpolate" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.is_gated_activation">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">is_gated_activation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">activation</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#is_gated_activation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.is_gated_activation" title="Permalink to this definition"></a></dt>
<dd><p>Is a given activation function gated?</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>activation</strong> – str
The name of the activation function.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the function is gated, False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.layer_norm">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">layer_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized_shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_diff_of_squares</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#layer_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.layer_norm" title="Permalink to this definition"></a></dt>
<dd><p>Add a layer-norm operation on a tensor.</p>
<p>That operation applies the layer-normalization to its input tensor. In its
simplest form, for large language models, the ‘normalized_shape’ should be
set to the hidden dimension of the activation tensor. Otherwise, it is the
shape of the normalized fraction of the tensor (starting from the
right-most dimension).</p>
<p>The ‘weight’ tensor corresponds to ‘gamma’ in the layer-norm formula and
‘bias’ is ‘beta’. The ‘eps’ value is added to the variance before computing
the squared-root.</p>
<p>This implementation (when using the plugin) supports an additional flag to
enable/disable the use of a difference of squares (‘Var = Mean(X^2) -
Mean(X)^2’).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The tensor to normalize.</p></li>
<li><p><strong>normalized_shape</strong> – Union[int, Tuple[int]]
The shape of the sub-tensor that is normalized. Use ‘hidden_dim’ to
normalize the inner-most dimension of an activation tensor in LLMs.</p></li>
<li><p><strong>weight</strong> – Optional[Tensor] = None
The ‘gamma’ term in layer-norm. Its shape must be
‘normalized_shape’.</p></li>
<li><p><strong>bias</strong> – Optional[Tensor] = None
The ‘beta’ term in layer-norm. Its shape must be
‘normalized_shape’.</p></li>
<li><p><strong>eps</strong> – float
The epsilon term to be added to the variance in the squared-root.</p></li>
<li><p><strong>use_diff_of_squares</strong> – bool
Does the plugin use the difference of squares to compute the
variance?</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The output tensor of that operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.lt">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">lt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.LESS:</span> <span class="pre">13&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.lt" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.matmul">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">matmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">transa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#matmul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.matmul" title="Permalink to this definition"></a></dt>
<dd><p>Add a matrix multiplication.</p>
<p>That operation maps to a tensorrt.IMatrixMultiplyLayer layer. As explained
in the TensorRT documentation, it computes the inner product between the
two inputs after applying an optional transposition on the inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The first tensor (often called A).</p></li>
<li><p><strong>mat2</strong> – Tensor
The second tensor (often called B).</p></li>
<li><p><strong>transa</strong> – bool
Is the first input transposed? Set to ‘True’ if you want the first
input to be transposed, ‘False’ otherwise.</p></li>
<li><p><strong>transb</strong> – bool
Is the second input transposed? Set to ‘True’ if you want the
second input to be transposed, ‘False’ otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the inserted layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.max">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#max"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.max" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to compute the max along a dimension.</p>
<p>Computes the max along the dimension ‘dim’ of the input tensor.</p>
<p>It is implemented using the IReduceLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>dim</strong> – int
The dimension along which the mean is computed.</p></li>
<li><p><strong>keepdim</strong> – bool
Is the dimension kept in the reduced tensor? When True the
dimension is kept, it is removed from the shape otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this reduction operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.maximum">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.MAX:</span> <span class="pre">2&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.maximum" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.mean">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.mean" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to compute the mean along a dimension.</p>
<p>Computes the mean along the dimension ‘dim’ of the input tensor.</p>
<p>It is implemented using the IReduceLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>dim</strong> – int
The dimension along which the mean is computed.</p></li>
<li><p><strong>keepdim</strong> – bool
Is the dimension kept in the reduced tensor? When True the
dimension is kept, it is removed from the shape otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this reduction operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.minimum">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.MIN:</span> <span class="pre">3&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.minimum" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.mul">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.PROD:</span> <span class="pre">1&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.mul" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.non_gated_version">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">non_gated_version</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">activation</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#non_gated_version"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.non_gated_version" title="Permalink to this definition"></a></dt>
<dd><p>Given an activation function, get the non-gated version.</p>
<p>If the activation function is non-gated, it returns the same activation
function name.</p>
<p>For example, that function returns ‘silu’ for ‘swiglu’ and ‘relu’ for
‘relu’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>activation</strong> – str
The name of the activation function.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The name of the non-gated activation function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.op_and">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">op_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.AND:</span> <span class="pre">8&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.op_and" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.op_or">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">op_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.OR:</span> <span class="pre">9&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.op_or" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.outer">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">outer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#outer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.outer" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to compute the outer product between two tensors.</p>
<p>That operation creates an Einsum node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The first input tensor.</p></li>
<li><p><strong>vec2</strong> – Tensor
The second input tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The output tensor produced by this layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.permute">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">permute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#permute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.permute" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to permute the dimensions of a tensor.</p>
<p>The dimensions of the input tensor are permutted according to the sequence
of dimensions in ‘dims’. That operation maps to tensorrt.IShuffleLayer where
the second transposition is described by the indices in ‘dims’.</p>
<p>Given a tensor of rank N, the result of the permutation is a tensor of rank
N in which the i-th input dimension maps to the dims[i]-th dimension.</p>
<p>For example, permute(input, [1, 0]) will transpose a 2D tensor by permuting
the rows and columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to permute.</p></li>
<li><p><strong>dims</strong> – Sequence[int]
The description of the permutation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the permutation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.pow">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">pow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.POW:</span> <span class="pre">6&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.pow" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.recv">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">recv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#recv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.recv" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that performs a recv to a rank from another.</p>
<p>The recv operation receives a tensor from on a rank from another. If a rank ‘i’
receives a tensor from a rank ‘j’, the rank ‘j’ must have a corresponding ‘send’
operation to rank ‘j’. See ‘send’.</p>
<p>That operation is implemented using a plugin that wraps the NCCL recv
point-to-point operation. See
<a class="reference external" href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/api/p2p.html#ncclrecv">https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/api/p2p.html#ncclrecv</a>
for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>src</strong> – int
The rank that sends the tensor to.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by that layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.relu">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">relu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_type:</span> <span class="pre">~tensorrt.tensorrt.ActivationType</span> <span class="pre">=</span> <span class="pre">&lt;ActivationType.RELU:</span> <span class="pre">0&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.relu" title="Permalink to this definition"></a></dt>
<dd><p>Add an activation function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p></li>
<li><p><strong>act_type</strong> – trt.ActivationType
The type of the activation (RELU, TANH, SIGMOID, …).</p></li>
</ul>
</dd>
</dl>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>relu    for op=trt.ActivationType.RELU
tanh    for op=trt.ActivationType.TANH
sigmoid for op=trt.ActivationType.SIGMOID</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.rms_norm">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">rms_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized_shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#rms_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.rms_norm" title="Permalink to this definition"></a></dt>
<dd><p>Add a RMS norm operation on a tensor.</p>
<p>That operation applies the rms-normalization to its input tensor. In its
simplest form, for large language models, the ‘normalized_shape’ should be
set to the hidden dimension of the activation tensor. Otherwise, it is the
shape of the normalized fraction of the tensor (starting from the
right-most dimension).</p>
<p>The ‘weight’ tensor corresponds to ‘gamma’ in the rms-norm formula.
The ‘eps’ value is added to the variance before computing the squared-root.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The tensor to normalize.</p></li>
<li><p><strong>normalized_shape</strong> – Union[int, Tuple[int]]
The shape of the sub-tensor that is normalized. Use ‘hidden_dim’ to
normalize the inner-most dimension of an activation tensor in LLMs.</p></li>
<li><p><strong>weight</strong> – Optional[Tensor] = None
The ‘gamma’ term in layer-norm. Its shape must be
‘normalized_shape’.</p></li>
<li><p><strong>eps</strong> – float
The epsilon term to be added to the variance in the squared-root.weig</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The output tensor of that operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.round">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.UnaryOperation</span> <span class="pre">=</span> <span class="pre">&lt;UnaryOperation.ROUND:</span> <span class="pre">22&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.round" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation on a single input.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>round   for op=trt.UnaryOperation.ROUND
sqrt    for op=trt.UnaryOperation.SQRT
exp     for op=trt.UnaryOperation.EXP
sin     for op=trt.UnaryOperation.SIN
cos     for op=trt.UnaryOperation.COS
abs     for op=trt.UnaryOperation.ABS</p>
</div></blockquote>
<p>It is implemented using the IUnaryLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>op</strong> – trt.UnaryOperation
The unary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.select">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">select</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#select"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.select" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to select a slice of elements from a tensor.</p>
<p>Given an input tensor, that function creates an operation that selects the
index-th slice of elements in the dimension ‘dim’ to create a new tensor.
The output tensor has a shape in which the input dimension ‘dim’ is
removed.</p>
<p>The ‘index’ can either be an integer or a 1D tensor containing a single
element.</p>
<p>For example, on input=[[4, 2, 5], [2, 1, 2], [4, 7, 1]], which has a shape
[3, 3],</p>
<blockquote>
<div><p>select(input, 0, 1)</p>
</div></blockquote>
<p>will create a tensor of shape [3] that contains the [2, 1, 2].</p>
<p>Regarding the shape of the output tensor, the dimension ‘dim’ is removed.
It means that for a tensor of shape [4, 2, 6, 3],</p>
<blockquote>
<div><p>select(input, 2, 4)</p>
</div></blockquote>
<p>will select the 5th slice (index == 4) from the 3rd dimension (dim == 2)
and return a tensor of shape [4, 2, 3] (i.e. the 3rd dimension is removed).</p>
<p>That operation maps to the TensorRT IGatherLayer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to select from.</p></li>
<li><p><strong>dim</strong> – int
The dimension to select from.</p></li>
<li><p><strong>index</strong> – Union[Tensor, int]
The index of the slice in the ‘dim’ dimension to select.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor containing the selected slice.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.send">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tgt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#send"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.send" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that performs a send from a rank to another.</p>
<p>The send operation sends a tensor from one rank to another. If a rank ‘i’
sends a tensor to a rank ‘j’, the rank ‘j’ must have a corresponding ‘recv’
operation from rank ‘i’. See ‘recv’.</p>
<p>That operation is implemented using a plugin that wraps the NCCL send
point-to-point operation. See
<a class="reference external" href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/api/p2p.html#ncclsend">https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/api/p2p.html#ncclsend</a>
for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>tgt</strong> – int
The rank that receives the tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by that layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.shape">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.shape" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to create a shape tensor.</p>
<p>The shape tensor can either be the shape of the input tensor when the
parameter dim is None or a scalar (tensor of rank 0) that corresponds to
the size of dim-th dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor from which we want to extract the shape or the
size in one dimension.</p></li>
<li><p><strong>dim</strong> – Optional[int]
The dimension from which to extract the size. If it is None, the
entire shape of the input tensor is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor that contains the shape of the input tensor (if ‘dim’ is None)
or the size in the dimension ‘dim’ of the input tensor. If ‘dim’ is
‘None’, that tensor has the same rank as the input tensor, otherwise
its rank is 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.sigmoid">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_type:</span> <span class="pre">~tensorrt.tensorrt.ActivationType</span> <span class="pre">=</span> <span class="pre">&lt;ActivationType.SIGMOID:</span> <span class="pre">1&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.sigmoid" title="Permalink to this definition"></a></dt>
<dd><p>Add an activation function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p></li>
<li><p><strong>act_type</strong> – trt.ActivationType
The type of the activation (RELU, TANH, SIGMOID, …).</p></li>
</ul>
</dd>
</dl>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>relu    for op=trt.ActivationType.RELU
tanh    for op=trt.ActivationType.TANH
sigmoid for op=trt.ActivationType.SIGMOID</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.silu">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">silu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#silu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.silu" title="Permalink to this definition"></a></dt>
<dd><p>Add a SiLU (<cite>x * sigmoid(x)</cite>) operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.sin">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.UnaryOperation</span> <span class="pre">=</span> <span class="pre">&lt;UnaryOperation.SIN:</span> <span class="pre">6&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.sin" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation on a single input.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>round   for op=trt.UnaryOperation.ROUND
sqrt    for op=trt.UnaryOperation.SQRT
exp     for op=trt.UnaryOperation.EXP
sin     for op=trt.UnaryOperation.SIN
cos     for op=trt.UnaryOperation.COS
abs     for op=trt.UnaryOperation.ABS</p>
</div></blockquote>
<p>It is implemented using the IUnaryLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>op</strong> – trt.UnaryOperation
The unary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.slice">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">starts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#slice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.slice" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to extract a slice from a tensor.</p>
<p>As described in the TensorRT documentation of the ISliceLayer, the slice
layer has two variants: Static and dynamic.</p>
<p>For static slicing, this function takes the starts and sizes values in the
different dimensions to slice at layer creation time via a sequence of
integers. For dynamic slicing, it accepts starts and sizes as
tensorrt.ITensor`s.</p>
<p>The slice layer selects for each dimension a start location from within the
input tensor, and copies elements to the output tensor using a stride of 1
across the input tensor. Start and size tensors must be 1-D int32 shape
tensors if not specified as a sequence of integers.</p>
<p>As an example, on input = [[0, 2, 4], [1, 3, 5]], the call to</p>
<blockquote>
<div><p>slice(input, start=[1, 0], size=[1, 2])</p>
</div></blockquote>
<p>will produce the tensor [[1, 3]] as output. The slice operator when
executed by TensorRT will copy one row (because size[0] == 1) starting from
the 2nd row (because start[0] == 1) and two columns (size[1] == 2) starting
from the 1st column (because start[1] == 0).</p>
<p>In pseudo-code the behaviour of that operation can be described as follows
for a 2D tensor (and easily be extended to more dimensions):</p>
<blockquote>
<div><p>output = Tensor(shape=sizes)
for ii in range(sizes[0]):</p>
<blockquote>
<div><dl class="simple">
<dt>for jj in range(sizes[1]):</dt><dd><p>output[ii][jj] = input[starts[0]+ii][starts[1]+jj]</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>Note that it is common in deep-learning frameworks to use ranges
[start:end] for similar operations. It can be emulated by setting the sizes
argument such that in each dimension [start:start+size] == [start:end] i.e.
size = end-start.</p>
<p>TensorRT supports different slice modes but that function restricts that
choice to <cite>mode == tensorrt.SliceMode.STRICT_BOUNDS</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the slicing is performed.</p></li>
<li><p><strong>starts</strong> – Union[Tensor, Sequence[int]]
The starting points, in the input tensor, and each dimension.</p></li>
<li><p><strong>sizes</strong> – Union[Tensor, Sequence[int]]
The number of elements in each dimension of the sliced tensor (output).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the slice layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.softmax">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">softmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#softmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.softmax" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to compute softmax on a tensor.</p>
<p>That operation computes the softmax on the input tensor in the dimension
‘dim’ if specified. Otherwise, it is applied on the last dimension.</p>
<p>It inserts a ISoftmaxLayer to the TensorRT graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which to apply softmax.</p></li>
<li><p><strong>dim</strong> – Optional[int]
The dimension used to apply softmax.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The output tensor of the softmax layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.softplus">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">softplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#softplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.softplus" title="Permalink to this definition"></a></dt>
<dd><p>Add the softplus activation base on PyTorch definition.</p>
<p>See <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.functional.softplus.html">https://pytorch.org/docs/stable/generated/torch.nn.functional.softplus.html</a> for a
description of that function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
Input TensorRT-LLM Tensor.</p></li>
<li><p><strong>beta</strong> – float
The parameter for softplus computation.</p></li>
<li><p><strong>threshold</strong> – float
The threshold for reverting to the linear function when input * beta &gt; threashold</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The output tensor created by that layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.split">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_size_or_sections</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.split" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation that splits a tensor into sub-tensors.</p>
<p>This operation creates a list of tensors that are obtained from the input
tensor by slicing it along the dimension ‘dim’. If ‘split_size_or_sections’
is an integer, the tensor is split into ‘input.shape[dim] /
split_size_or_sections’ slices. If ‘split_size_or_sections’ is a list of
sizes, the tensor is split into ‘len(split_size_or_sections)’ slices and
the size of the ith slice is given by ‘split_size_or_sections[i]’.</p>
<p>There are several constraints with the current implementation:</p>
<blockquote>
<div><ul class="simple">
<li><p>The input tensor must be static (no dynamic dimension),</p></li>
<li><p>If ‘split_size_or_sections’ is an integer, the number of elements in
the ‘dim’ dimension of the input must be a multiple of
‘split_size_or_sections’: ‘input.shape[dim] % split_size_or_sections == 0’.</p></li>
<li><p>If ‘split_size_or_sections’ is a sequence, the sum of the elements in
‘split_size_or_sections’ must be equal to the size in the dimension
‘dim’: ‘input.shape[dim] == sum(ii for ii in split_size_or_sections)’.</p></li>
</ul>
</div></blockquote>
<p>That operation is implemented using a ‘slice’ operation for each output
slice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor
The input tensor to slice.</p></li>
<li><p><strong>split_size_or_sections</strong> – Union[int, Sequence[int]]
If it is an integer, it encodes the size of each slice. Otherwise,
if it is a sequence, it is the size of each slice.</p></li>
<li><p><strong>dim</strong> – int
The dimension of the tensor to slice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of tensors produced by the different operations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.sqrt">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.UnaryOperation</span> <span class="pre">=</span> <span class="pre">&lt;UnaryOperation.SQRT:</span> <span class="pre">2&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.sqrt" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation on a single input.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>round   for op=trt.UnaryOperation.ROUND
sqrt    for op=trt.UnaryOperation.SQRT
exp     for op=trt.UnaryOperation.EXP
sin     for op=trt.UnaryOperation.SIN
cos     for op=trt.UnaryOperation.COS
abs     for op=trt.UnaryOperation.ABS</p>
</div></blockquote>
<p>It is implemented using the IUnaryLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>op</strong> – trt.UnaryOperation
The unary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.squared_relu">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">squared_relu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#squared_relu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.squared_relu" title="Permalink to this definition"></a></dt>
<dd><p>Add a Squared ReLU operation.</p>
<p>This function applies ReLU and squares the output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.sub">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op:</span> <span class="pre">~tensorrt.tensorrt.ElementWiseOperation</span> <span class="pre">=</span> <span class="pre">&lt;ElementWiseOperation.SUB:</span> <span class="pre">4&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.sub" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation with two inputs.</p>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
elementwise operation ‘op’.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>add     for op=trt.ElementWiseOperation.SUM
sub     for op=trt.ElementWiseOperation.SUB
mul     for op=trt.ElementWiseOperation.PROD
div     for op=trt.ElementWiseOperation.DIV
gt      for op=trt.ElementWiseOperation.GREATER
lt      for op=trt.ElementWiseOperation.LESS
op_and  for op=trt.ElementWiseOperation.AND
op_or   for op=trt.ElementWiseOperation.OR
eq      for op=trt.ElementWiseOperation.EQUAL
minimum for op=trt.ElementWiseOperation.MIN
maximum for op=trt.ElementWiseOperation.MAX
pow     for op=trt.ElementWiseOperation.POW</p>
</div></blockquote>
<p>It is implemented using the IElementWiseLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.swiglu">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">swiglu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#swiglu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.swiglu" title="Permalink to this definition"></a></dt>
<dd><p>Add a SwiGLU (<cite>x * SiLU(gate)</cite>) operation.</p>
<p>That function takes a tensor, splits it into two halves along the last
dimension, applies SiLU to the second half and multiply the results. The
behaviour is undefined if the last dimension is not even.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.tanh">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input:</span> <span class="pre">~tensorrt_llm.functional.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_type:</span> <span class="pre">~tensorrt.tensorrt.ActivationType</span> <span class="pre">=</span> <span class="pre">&lt;ActivationType.TANH:</span> <span class="pre">2&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="headerlink" href="#tensorrt_llm.functional.tanh" title="Permalink to this definition"></a></dt>
<dd><p>Add an activation function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor on which the activation function is applied.</p></li>
<li><p><strong>act_type</strong> – trt.ActivationType
The type of the activation (RELU, TANH, SIGMOID, …).</p></li>
</ul>
</dd>
</dl>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>relu    for op=trt.ActivationType.RELU
tanh    for op=trt.ActivationType.TANH
sigmoid for op=trt.ActivationType.SIGMOID</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The tensor produced by the activation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.transpose">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.transpose" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to transpose two dimensions of a tensor.</p>
<p>That operation produces a tensor in which the dimensions ‘dim0’ and ‘dim1’
are permuted. The other dimensions, if the rank of the tensor is greater
than 2, remain untouched.</p>
<p>That function is a helper built on the ‘functional.permute’ function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to transpose.</p></li>
<li><p><strong>dim0</strong> – int
The first dimension to transpose.</p></li>
<li><p><strong>dim1</strong> – int
The second dimension to transpose.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the permutation layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.unary">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">unary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">UnaryOperation</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#unary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.unary" title="Permalink to this definition"></a></dt>
<dd><p>Add an elementwise operation on a single input.</p>
<p>The following closures are defined in functional.*:</p>
<blockquote>
<div><p>round   for op=trt.UnaryOperation.ROUND
sqrt    for op=trt.UnaryOperation.SQRT
exp     for op=trt.UnaryOperation.EXP
sin     for op=trt.UnaryOperation.SIN
cos     for op=trt.UnaryOperation.COS
abs     for op=trt.UnaryOperation.ABS</p>
</div></blockquote>
<p>It is implemented using the IUnaryLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor.</p></li>
<li><p><strong>op</strong> – trt.UnaryOperation
The unary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this elementwise operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.unsqueeze">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">unsqueeze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#unsqueeze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.unsqueeze" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to insert a singleton dimension to a tensor.</p>
<p>That functions creates an operation that insert a singleton dimension
(dimension of size 1) at position ‘dim’ in the output tensor. It works with
negative values for the ‘axis’.</p>
<p>For example, for a tensor ‘input’ of shape [4, 4]:</p>
<blockquote>
<div><p>unsqueeze(input,  0) will produce an output of shape [1, 4, 4],
unsqueeze(input,  1) will produce an output of shape [4, 1, 4],
unsqueeze(input, -1) will produce an output of shape [4, 4, 1],
unsqueeze(input, -2) will produce an output of shape [4, 1, 4],</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to expand with a singleton dimension.</p></li>
<li><p><strong>axis</strong> – int
The index of the singleton dimension in the output tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.view">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_is_placeholder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#view"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.view" title="Permalink to this definition"></a></dt>
<dd><p>Add an operation to create a view of a tensor.</p>
<p>That operation adds a tensorrt.IShuffleLayer to the network. If the ‘shape’
parameter is a Tensor, that view is dynamic. Otherwise, it is a static
view.</p>
<p>Note that TensorRT limits the number of inferred dimensions to 1. It means
that the shape sequence or tensor cannot contain more than one -1. This
function enforces that constraint and will assert if it is not respected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – Tensor
The input tensor to transpose.</p></li>
<li><p><strong>shape</strong> – Union[Tensor, Sequence[int]]
The shape of the new tensor.</p></li>
<li><p><strong>zero_is_placeholder</strong> – bool
When that parameter is True, the 0s in ‘shape’ are replaced by the
sizes of the corresponding dimensions from the ‘input’. Otherwise,
the dimensions corresponding to 0s are shrinked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by the view/shuffle layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tensorrt_llm.functional.where">
<span class="sig-prename descclassname"><span class="pre">tensorrt_llm.functional.</span></span><span class="sig-name descname"><span class="pre">where</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tensorrt_llm.functional.Tensor" title="tensorrt_llm.functional.Tensor"><span class="pre">Tensor</span></a></span></span><a class="reference internal" href="../_modules/tensorrt_llm/functional.html#where"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorrt_llm.functional.where" title="Permalink to this definition"></a></dt>
<dd><p>Add a where (aka select or if-then-else) operation.</p>
<p>Assuming the three input parameters have the same shape, that function creates
the operation to compute a tensor of the same shape such that:</p>
<blockquote>
<div><dl class="simple">
<dt>for ii in range(mul(condition.shape)):</dt><dd><p>output[ii] = left[ii] if condition[ii] else right[ii]</p>
</dd>
</dl>
</div></blockquote>
<p>For each input, that function first creates a constant tensor if the input
is an integer or a float. Then, if needed, it expands the smaller tensor to
make sure its rank is the same as the larger one. Then, it performs the
selection.</p>
<p>It is implemented using the ISelectLayer from TensorRT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> – Union[Tensor, int, float]
The condition. If that input is an integer or a float, the function
creates a constant tensor.</p></li>
<li><p><strong>left</strong> – Union[Tensor, int, float]
The first input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>right</strong> – Union[Tensor, int, float]
The second input. If that input is an integer or a float, the
function creates a constant tensor.</p></li>
<li><p><strong>op</strong> – trt.ElementWiseOperation
The binary operation to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tensor produced by this select operation.</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tensorrt_llm.layers.html" class="btn btn-neutral float-left" title="Layers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tensorrt_llm.models.html" class="btn btn-neutral float-right" title="Models" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, NVidia.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>